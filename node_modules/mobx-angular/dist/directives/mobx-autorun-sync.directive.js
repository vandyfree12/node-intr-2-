var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Directive, ViewContainerRef, TemplateRef, Renderer } from '@angular/core';
import { autorun } from 'mobx';
import { MobxAutorunDirective } from './mobx-autorun.directive';
var MobxAutorunSyncDirective = /** @class */ (function (_super) {
    __extends(MobxAutorunSyncDirective, _super);
    function MobxAutorunSyncDirective(templateRef, viewContainer, renderer) {
        var _this = _super.call(this, templateRef, viewContainer, renderer) || this;
        _this.templateRef = templateRef;
        _this.viewContainer = viewContainer;
        _this.renderer = renderer;
        return _this;
    }
    MobxAutorunSyncDirective.prototype.autoDetect = function (view) {
        console.warn('mobxAutorunSync is deprecated, please use mobxAutorun instead - it\'s doing exactly the same thing');
        this.dispose = autorun(function () {
            view['detectChanges']();
        });
    };
    MobxAutorunSyncDirective.decorators = [
        { type: Directive, args: [{ selector: '[mobxAutorunSync]' },] },
    ];
    /** @nocollapse */
    MobxAutorunSyncDirective.ctorParameters = function () { return [
        { type: TemplateRef, },
        { type: ViewContainerRef, },
        { type: Renderer, },
    ]; };
    return MobxAutorunSyncDirective;
}(MobxAutorunDirective));
export { MobxAutorunSyncDirective };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ieC1hdXRvcnVuLXN5bmMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2RpcmVjdGl2ZXMvbW9ieC1hdXRvcnVuLXN5bmMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQzs7SUFHaEIsNENBQW9CO0lBQ2hFLGtDQUNZLFdBQTZCLEVBQzdCLGFBQStCLEVBQy9CLFFBQWtCO1FBSDlCLFlBR2lDLGtCQUFNLFdBQVcsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDLFNBQUc7UUFGbkUsaUJBQVcsR0FBWCxXQUFXLENBQWtCO1FBQzdCLG1CQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixjQUFRLEdBQVIsUUFBUSxDQUFVOztLQUFpRDtJQUUvRSw2Q0FBVSxHQUFWLFVBQVcsSUFBSTtRQUNiLE9BQU8sQ0FBQyxJQUFJLENBQUMsb0dBQW9HLENBQUMsQ0FBQztRQUVuSCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztZQUNyQixJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUUsQ0FBQztTQUN6QixDQUFDLENBQUM7S0FDSjs7Z0JBYkYsU0FBUyxTQUFDLEVBQUUsUUFBUSxFQUFFLG1CQUFtQixFQUFFOzs7O2dCQUpOLFdBQVc7Z0JBQTdCLGdCQUFnQjtnQkFBZSxRQUFROzttQ0FBM0Q7RUFLOEMsb0JBQW9CO1NBQXJELHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiwgVGVtcGxhdGVSZWYsIFJlbmRlcmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBhdXRvcnVuIH0gZnJvbSAnbW9ieCc7XG5pbXBvcnQge01vYnhBdXRvcnVuRGlyZWN0aXZlfSBmcm9tICcuL21vYngtYXV0b3J1bi5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbW9ieEF1dG9ydW5TeW5jXScgfSlcbmV4cG9ydCBjbGFzcyBNb2J4QXV0b3J1blN5bmNEaXJlY3RpdmUgZXh0ZW5kcyBNb2J4QXV0b3J1bkRpcmVjdGl2ZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByb3RlY3RlZCB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICBwcm90ZWN0ZWQgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyKSB7c3VwZXIodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXIsIHJlbmRlcmVyKTsgfVxuXG4gIGF1dG9EZXRlY3Qodmlldykge1xuICAgIGNvbnNvbGUud2FybignbW9ieEF1dG9ydW5TeW5jIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbW9ieEF1dG9ydW4gaW5zdGVhZCAtIGl0XFwncyBkb2luZyBleGFjdGx5IHRoZSBzYW1lIHRoaW5nJyk7XG5cbiAgICB0aGlzLmRpc3Bvc2UgPSBhdXRvcnVuKCgpID0+IHtcbiAgICAgIHZpZXdbJ2RldGVjdENoYW5nZXMnXSgpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=
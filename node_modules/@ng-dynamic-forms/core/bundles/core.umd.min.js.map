{"version":3,"file":"core.umd.min.js","sources":["../../../es5/core/src/decorator/serializable.decorator.ts","../../../es5/core/src/model/dynamic-form-control.model.ts","../../../es5/core/src/model/dynamic-form-value-control.model.ts","../../../es5/core/src/model/form-array/dynamic-form-array.model.ts","../../../es5/core/src/utils/autofill.utils.ts","../../../es5/core/src/model/dynamic-input-control.model.ts","../../../es5/core/src/utils/json.utils.ts","../../../es5/core/src/model/input/dynamic-input.model.ts","../../../es5/core/src/directive/dynamic-template.directive.ts","../../../es5/core/src/utils/relation.utils.ts","../../../es5/core/src/model/misc/dynamic-form-control-relation.model.ts","../../../es5/core/src/component/dynamic-form-control.component.ts","../../../es5/core/src/component/dynamic-form-component.ts","../../../es5/core/src/directive/dynamic-id.directive.ts","../../../es5/core/src/model/dynamic-check-control.model.ts","../../../es5/core/src/model/dynamic-date-control.model.ts","../../../es5/core/src/model/dynamic-file-control.model.ts","../../../../node_modules/rxjs/src/util/root.ts","../../../../node_modules/rxjs/src/util/isObject.ts","../../../../node_modules/rxjs/src/util/tryCatch.ts","../../../../node_modules/rxjs/src/util/UnsubscriptionError.ts","../../../../node_modules/rxjs/src/Subscription.ts","../../../../node_modules/rxjs/src/Observer.ts","../../../../node_modules/rxjs/src/symbol/rxSubscriber.ts","../../../../node_modules/rxjs/src/Subscriber.ts","../../../../node_modules/rxjs/src/symbol/observable.ts","../../../../node_modules/rxjs/src/Observable.ts","../../../../node_modules/rxjs/src/util/toSubscriber.ts","../../../../node_modules/rxjs/src/util/pipe.ts","../../../../node_modules/rxjs/src/observable/ScalarObservable.ts","../../../../node_modules/rxjs/src/observable/EmptyObservable.ts","../../../../node_modules/rxjs/src/util/isScheduler.ts","../../../../node_modules/rxjs/src/observable/ArrayObservable.ts","../../../../node_modules/rxjs/src/util/MapPolyfill.ts","../../../../node_modules/rxjs/src/operators/map.ts","../../../es5/core/src/model/dynamic-option-control.model.ts","../../../es5/core/src/model/checkbox/dynamic-checkbox.model.ts","../../../es5/core/src/model/form-group/dynamic-form-group.model.ts","../../../es5/core/src/model/checkbox/dynamic-checkbox-group.model.ts","../../../es5/core/src/model/colorpicker/dynamic-colorpicker.model.ts","../../../es5/core/src/model/datepicker/dynamic-datepicker.model.ts","../../../es5/core/src/model/editor/dynamic-editor.model.ts","../../../es5/core/src/model/file-upload/dynamic-file-upload.model.ts","../../../es5/core/src/model/radio/dynamic-radio-group.model.ts","../../../es5/core/src/model/rating/dynamic-rating.model.ts","../../../es5/core/src/model/select/dynamic-select.model.ts","../../../es5/core/src/model/slider/dynamic-slider.model.ts","../../../es5/core/src/model/switch/dynamic-switch.model.ts","../../../es5/core/src/model/textarea/dynamic-textarea.model.ts","../../../es5/core/src/model/timepicker/dynamic-timepicker.model.ts","../../../es5/core/src/service/dynamic-form-validation.service.ts","../../../es5/core/src/service/dynamic-form.service.ts","../../../es5/core/src/service/dynamic-form-layout.service.ts","../../../es5/core/src/core.module.ts"],"sourcesContent":["declare let Reflect: any;\n\nexport const METADATA_KEY_SERIALIZABLE = \"SERIALIZABLE\";\n\nexport interface SerializableProperty {\n\n    key: string;\n    name: string;\n}\n\nexport function serializable(name?: string): (target: any, key: string) => void {\n\n    return function (target, key) {\n        Reflect.defineMetadata(METADATA_KEY_SERIALIZABLE, {key: key, name: name || key}, target, key);\n    };\n}\n\nexport function getSerializables(target: any): SerializableProperty[] {\n\n    let serializables = [];\n\n    for (let key in target) {\n\n        let metadata = Reflect.getMetadata(METADATA_KEY_SERIALIZABLE, target, key);\n\n        if (metadata) {\n            serializables.push(metadata);\n        }\n    }\n\n    return serializables;\n}\n\nexport function serialize(target: any, prototype?: any): Object {\n\n    return getSerializables(prototype || target).reduce((prev: any, prop: SerializableProperty) => {\n\n        prev[prop.name] = target[prop.key];\n\n        return prev;\n\n    }, {});\n}","import { FormHooks } from \"@angular/forms/src/model\";\nimport { Subject } from \"rxjs/Subject\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { DynamicPathable } from \"./misc/dynamic-form-control-path.model\";\nimport { DynamicFormControlRelationGroup } from \"./misc/dynamic-form-control-relation.model\";\nimport { DynamicValidatorsConfig } from \"./misc/dynamic-form-control-validation.model\";\nimport { serializable, serialize } from \"../decorator/serializable.decorator\";\n\nexport interface DynamicFormControlModelConfig {\n\n    asyncValidators?: DynamicValidatorsConfig;\n    disabled?: boolean;\n    errorMessages?: DynamicValidatorsConfig;\n    hidden?: boolean;\n    id: string;\n    label?: string;\n    name?: string;\n    relation?: DynamicFormControlRelationGroup[];\n    updateOn?: FormHooks;\n    validators?: DynamicValidatorsConfig;\n}\n\nexport abstract class DynamicFormControlModel implements DynamicPathable {\n\n    @serializable() asyncValidators: DynamicValidatorsConfig | null;\n    @serializable(\"disabled\") _disabled: boolean;\n    disabledUpdates: Subject<boolean>;\n    @serializable() errorMessages: DynamicValidatorsConfig | null;\n    @serializable() hidden: boolean;\n    @serializable() id: string;\n    @serializable() label: string | null;\n    @serializable() layout: DynamicFormControlLayout | null;\n    @serializable() name: string;\n    parent: DynamicPathable | null = null;\n    @serializable() relation: DynamicFormControlRelationGroup[];\n    @serializable() updateOn: FormHooks | null;\n    @serializable() validators: DynamicValidatorsConfig | null;\n\n    /*@deprecated*/ readonly cls: DynamicFormControlLayout | null;\n\n    abstract readonly type: string;\n\n    constructor(config: DynamicFormControlModelConfig, layout: DynamicFormControlLayout | null = null) {\n\n        this.asyncValidators = config.asyncValidators || null;\n        this.errorMessages = config.errorMessages || null;\n        this.hidden = typeof config.hidden === \"boolean\" ? config.hidden : false;\n        this.id = config.id;\n        this.label = config.label || null;\n        this.layout = layout;\n        this.name = config.name || config.id;\n        this.relation = Array.isArray(config.relation) ? config.relation : [];\n        this.updateOn = typeof config.updateOn === \"string\" ? config.updateOn : null;\n        this.validators = config.validators || null;\n\n        this.disabled = typeof config.disabled === \"boolean\" ? config.disabled : false;\n        this.disabledUpdates = new Subject<boolean>();\n        this.disabledUpdates.subscribe(disabled => this.disabled = disabled);\n    }\n\n    get disabled(): boolean {\n        return this._disabled;\n    }\n\n    set disabled(value: boolean) {\n        this._disabled = value;\n    }\n\n    get hasErrorMessages(): boolean {\n        return typeof this.errorMessages === \"object\" && this.errorMessages !== null;\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}","import { Subject } from \"rxjs/Subject\";\nimport { DynamicFormControlModel, DynamicFormControlModelConfig } from \"./dynamic-form-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\n\nexport type DynamicFormControlValue = boolean | number | string | object | Date |\n    Array<boolean | number | string | object>;\n\nexport interface DynamicFormValueControlModelConfig<T> extends DynamicFormControlModelConfig {\n\n    additional?: { [key: string]: any };\n    hint?: string;\n    required?: boolean;\n    tabIndex?: number;\n    value?: T;\n}\n\nexport abstract class DynamicFormValueControlModel<T> extends DynamicFormControlModel {\n\n    @serializable() additional: { [key: string]: any } | null;\n    @serializable() hint: string | null;\n    @serializable() required: boolean;\n    @serializable() tabIndex: number | null;\n    @serializable(\"value\") _value: T | null;\n    valueUpdates: Subject<T>;\n\n    constructor(config: DynamicFormValueControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.additional = typeof config.additional === \"object\" && config.additional !== null ? config.additional : null;\n        this.hint = config.hint || null;\n        this.required = typeof config.required === \"boolean\" ? config.required : false;\n        this.tabIndex = config.tabIndex || null;\n\n        this.value = config.value || null;\n        this.valueUpdates = new Subject<T>();\n        this.valueUpdates.subscribe((value: T) => this.value = value);\n    }\n\n    set value(value: T | null) {\n        this._value = value;\n    }\n\n    get value(): T | null {\n        return this._value;\n    }\n}","import { DynamicFormControlModel, DynamicFormControlModelConfig } from \"../dynamic-form-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { DynamicPathable } from \"../misc/dynamic-form-control-path.model\";\nimport { DynamicValidatorsConfig } from \"../misc/dynamic-form-control-validation.model\";\nimport { serializable, serialize } from \"../../decorator/serializable.decorator\";\n\nexport class DynamicFormArrayGroupModel implements DynamicPathable {\n\n    $implicit: DynamicFormArrayGroupModel;\n    context: DynamicFormArrayModel;\n    @serializable() group: DynamicFormControlModel[];\n    @serializable() index: number;\n\n    constructor(context: DynamicFormArrayModel, group: DynamicFormControlModel[] = [], index: number = -1) {\n\n        this.$implicit = this;\n        this.context = context;\n        this.group = group;\n        this.index = index;\n    }\n\n    get parent(): DynamicFormArrayModel {\n        return this.context;\n    }\n\n    get(index: number): DynamicFormControlModel {\n        return this.group[index];\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_ARRAY = \"ARRAY\";\n\nexport interface DynamicFormArrayModelConfig extends DynamicFormControlModelConfig {\n\n    groupAsyncValidators?: DynamicValidatorsConfig;\n    groupFactory?: () => DynamicFormControlModel[];\n    groupValidators?: DynamicValidatorsConfig;\n    groups?: DynamicFormArrayGroupModel[] | null;\n    initialCount?: number;\n}\n\nexport class DynamicFormArrayModel extends DynamicFormControlModel {\n\n    @serializable() groupAsyncValidators: DynamicValidatorsConfig | null;\n    groupFactory: () => DynamicFormControlModel[];\n    @serializable() groupValidators: DynamicValidatorsConfig | null;\n    @serializable() groups: DynamicFormArrayGroupModel[] = [];\n    @serializable() initialCount: number;\n\n    @serializable() readonly groupPrototype: DynamicFormControlModel[]; // only to recreate model from JSON\n    /*@deprecated*/ readonly origin: DynamicFormControlModel[];\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_ARRAY;\n\n    constructor(config: DynamicFormArrayModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        if (typeof config.groupFactory === \"function\") {\n            this.groupFactory = config.groupFactory;\n        } else {\n            throw new Error(\"group factory function must be specified for DynamicFormArrayModel\");\n        }\n\n        this.groupAsyncValidators = config.groupAsyncValidators || null;\n        this.groupPrototype = this.groupFactory();\n        this.groupValidators = config.groupValidators || null;\n        this.initialCount = typeof config.initialCount === \"number\" ? config.initialCount : 1;\n\n        if (Array.isArray(config.groups)) {\n\n            config.groups.forEach((arrayGroup, index) => {\n                this.groups.push(new DynamicFormArrayGroupModel(this, arrayGroup.group, arrayGroup.index || index));\n            });\n\n        } else {\n\n            for (let index = 0; index < this.initialCount; index++) {\n                this.addGroup();\n            }\n        }\n    }\n\n    private updateGroupIndex(): void {\n        this.groups.forEach((group, index) => group.index = index);\n    }\n\n    get size(): number {\n        return this.groups.length;\n    }\n\n    get(index: number): DynamicFormArrayGroupModel {\n        return this.groups[index];\n    }\n\n    addGroup(): DynamicFormArrayGroupModel {\n        return this.insertGroup(this.groups.length);\n    }\n\n    insertGroup(index: number): DynamicFormArrayGroupModel {\n\n        let group = new DynamicFormArrayGroupModel(this, this.groupFactory());\n\n        this.groups.splice(index, 0, group);\n        this.updateGroupIndex();\n\n        return group;\n    }\n\n    moveGroup(index: number, step: number): void {\n\n        this.groups.splice(index + step, 0, ...this.groups.splice(index, 1));\n        this.updateGroupIndex();\n    }\n\n    removeGroup(index: number): void {\n\n        this.groups.splice(index, 1);\n        this.updateGroupIndex();\n    }\n}","export const AUTOCOMPLETE_OFF = \"off\";\nexport const AUTOCOMPLETE_ON = \"on\";\n\nexport const AUTOFILL_TOKEN_BILLING = \"billing\";\nexport const AUTOFILL_TOKEN_SHIPPING = \"shipping\";\n\nexport const AUTOFILL_TOKENS_ADDRESS = [AUTOFILL_TOKEN_BILLING, AUTOFILL_TOKEN_SHIPPING];\n\nexport const AUTOFILL_TOKEN_HOME = \"home\";\nexport const AUTOFILL_TOKEN_WORK = \"work\";\nexport const AUTOFILL_TOKEN_MOBILE = \"mobile\";\nexport const AUTOFILL_TOKEN_FAX = \"fax\";\nexport const AUTOFILL_TOKEN_PAGER = \"pager\";\n\nexport const AUTOFILL_TOKENS_CONTACT = [\n    AUTOFILL_TOKEN_FAX, AUTOFILL_TOKEN_HOME, AUTOFILL_TOKEN_MOBILE, AUTOFILL_TOKEN_PAGER, AUTOFILL_TOKEN_WORK\n];\n\nexport const AUTOFILL_FIELD_STREET_ADDRESS = \"street-address\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_1 = \"address-line1\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_2 = \"address-line2\";\nexport const AUTOFILL_FIELD_ADDRESS_LINE_3 = \"address-line3\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_4 = \"address-level4\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_3 = \"address-level3\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_2 = \"address-level2\";\nexport const AUTOFILL_FIELD_ADDRESS_LEVEL_1 = \"address-level1\";\n\nexport const AUTOFILL_FIELD_NAME = \"name\";\nexport const AUTOFILL_FIELD_HONORIFIC_PREFIX = \"honorific-prefix\";\nexport const AUTOFILL_FIELD_GIVEN_NAME = \"given-name\";\nexport const AUTOFILL_FIELD_ADDITIONAL_NAME = \"additional-name\";\nexport const AUTOFILL_FIELD_FAMILY_NAME = \"family-name\";\nexport const AUTOFILL_FIELD_HONORIFIC_SUFFIX = \"honorific-suffix\";\nexport const AUTOFILL_FIELD_NICKNAME = \"nickname\";\nexport const AUTOFILL_FIELD_USERNAME = \"username\";\n\nexport const AUTOFILL_FIELD_NEW_PASSWORD = \"new-password\";\nexport const AUTOFILL_FIELD_CURRENT_PASSWORD = \"current-password\";\n\nexport const AUTOFILL_FIELD_ORGANIZATION_TITLE = \"organization-title\";\nexport const AUTOFILL_FIELD_ORGANIZATION = \"organization\";\n\nexport const AUTOFILL_FIELD_COUNTRY = \"country\";\nexport const AUTOFILL_FIELD_COUNTRY_NAME = \"country-name\";\nexport const AUTOFILL_FIELD_POSTAL_CODE = \"postal-code\";\n\nexport const AUTOFILL_FIELD_CC_NAME = \"cc-name\";\nexport const AUTOFILL_FIELD_CC_GIVEN_NAME = \"cc-given-name\";\nexport const AUTOFILL_FIELD_CC_ADDITIONAL_NAME = \"cc-additional-name\";\nexport const AUTOFILL_FIELD_CC_FAMILY_NAME = \"cc-family-name\";\nexport const AUTOFILL_FIELD_CC_NUMBER = \"cc-number\";\nexport const AUTOFILL_FIELD_CC_EXP = \"cc-exp\";\nexport const AUTOFILL_FIELD_CC_EXP_MONTH = \"cc-exp-month\";\nexport const AUTOFILL_FIELD_CC_EXP_YEAR = \"cc-exp-year\";\nexport const AUTOFILL_FIELD_CC_CSC = \"cc-csc\";\nexport const AUTOFILL_FIELD_CC_TYPE = \"cc-type\";\n\nexport const AUTOFILL_FIELD_TRANSACTION_CURRENCY = \"transaction-currency\";\nexport const AUTOFILL_FIELD_TRANSACTION_AMOUNT = \"transaction-amount\";\n\nexport const AUTOFILL_FIELD_LANGUAGE = \"language\";\n\nexport const AUTOFILL_FIELD_BDAY = \"bday\";\nexport const AUTOFILL_FIELD_BDAY_DAY = \"bday-day\";\nexport const AUTOFILL_FIELD_BDAY_MONTH = \"bday-month\";\nexport const AUTOFILL_FIELD_BDAY_YEAR = \"bday-year\";\n\nexport const AUTOFILL_FIELD_SEX = \"sex\";\n\nexport const AUTOFILL_FIELD_URL = \"url\";\n\nexport const AUTOFILL_FIELD_PHOTO = \"photo\";\n\nexport const AUTOFILL_FIELDS = [\n\n    AUTOFILL_FIELD_STREET_ADDRESS, AUTOFILL_FIELD_ADDRESS_LINE_1, AUTOFILL_FIELD_ADDRESS_LINE_2,\n    AUTOFILL_FIELD_ADDRESS_LINE_3, AUTOFILL_FIELD_ADDRESS_LEVEL_4, AUTOFILL_FIELD_ADDRESS_LEVEL_3,\n    AUTOFILL_FIELD_ADDRESS_LEVEL_2, AUTOFILL_FIELD_ADDRESS_LEVEL_1, AUTOFILL_FIELD_NAME,\n    AUTOFILL_FIELD_HONORIFIC_PREFIX, AUTOFILL_FIELD_GIVEN_NAME, AUTOFILL_FIELD_ADDITIONAL_NAME,\n    AUTOFILL_FIELD_FAMILY_NAME, AUTOFILL_FIELD_HONORIFIC_SUFFIX, AUTOFILL_FIELD_NICKNAME, AUTOFILL_FIELD_USERNAME,\n    AUTOFILL_FIELD_NEW_PASSWORD, AUTOFILL_FIELD_CURRENT_PASSWORD, AUTOFILL_FIELD_ORGANIZATION_TITLE,\n    AUTOFILL_FIELD_ORGANIZATION, AUTOFILL_FIELD_COUNTRY, AUTOFILL_FIELD_COUNTRY_NAME, AUTOFILL_FIELD_POSTAL_CODE,\n    AUTOFILL_FIELD_CC_NAME, AUTOFILL_FIELD_CC_GIVEN_NAME, AUTOFILL_FIELD_CC_ADDITIONAL_NAME,\n    AUTOFILL_FIELD_CC_FAMILY_NAME, AUTOFILL_FIELD_CC_NUMBER, AUTOFILL_FIELD_CC_EXP, AUTOFILL_FIELD_CC_EXP_MONTH,\n    AUTOFILL_FIELD_CC_EXP_YEAR, AUTOFILL_FIELD_CC_CSC, AUTOFILL_FIELD_CC_TYPE, AUTOFILL_FIELD_TRANSACTION_CURRENCY,\n    AUTOFILL_FIELD_TRANSACTION_AMOUNT, AUTOFILL_FIELD_LANGUAGE, AUTOFILL_FIELD_BDAY, AUTOFILL_FIELD_BDAY_DAY,\n    AUTOFILL_FIELD_BDAY_MONTH, AUTOFILL_FIELD_BDAY_YEAR, AUTOFILL_FIELD_SEX, AUTOFILL_FIELD_URL, AUTOFILL_FIELD_PHOTO\n];\n\nexport const AUTOFILL_FIELD_TEL = \"tel\";\nexport const AUTOFILL_FIELD_TEL_COUNTRY_CODE = \"tel-country-code\";\nexport const AUTOFILL_FIELD_TEL_NATIONAL = \"tel-national\";\nexport const AUTOFILL_FIELD_TEL_AREA_CODE = \"tel-area-code\";\nexport const AUTOFILL_FIELD_TEL_LOCAL = \"tel-local\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_PREFIX = \"tel-local-prefix\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_SUFFIX = \"tel-local-suffix\";\nexport const AUTOFILL_FIELD_TEL_LOCAL_EXTENSION = \"tel-extension\";\nexport const AUTOFILL_FIELD_EMAIL = \"email\";\nexport const AUTOFILL_FIELD_IMPP = \"impp\";\n\nexport const AUTOFILL_FIELDS_CONTACT = [\n\n    AUTOFILL_FIELD_TEL, AUTOFILL_FIELD_TEL_COUNTRY_CODE, AUTOFILL_FIELD_TEL_NATIONAL, AUTOFILL_FIELD_TEL_AREA_CODE,\n    AUTOFILL_FIELD_TEL_LOCAL, AUTOFILL_FIELD_TEL_LOCAL_PREFIX, AUTOFILL_FIELD_TEL_LOCAL_SUFFIX,\n    AUTOFILL_FIELD_TEL_LOCAL_EXTENSION, AUTOFILL_FIELD_EMAIL, AUTOFILL_FIELD_IMPP\n];\n\nexport class AutoFillUtils {\n\n    static isAddressToken(token: string): boolean {\n        return AUTOFILL_TOKENS_ADDRESS.indexOf(token) > -1;\n    }\n\n    static isContactField(token: string): boolean {\n        return AUTOFILL_FIELDS_CONTACT.indexOf(token) > -1;\n    }\n\n    static isContactToken(token: string): boolean {\n        return AUTOFILL_TOKENS_CONTACT.indexOf(token) > -1;\n    }\n\n    static isField(token: string): boolean {\n        return AUTOFILL_FIELDS.indexOf(token) > -1;\n    }\n\n    static isSectionToken(token: string): boolean {\n        return token.startsWith(\"section-\");\n    }\n\n    static validate(tokens: string): boolean {\n\n        let toExpression = (total: string, currentValue: string) => `${total}|${currentValue}`,\n            tokensAddress = AUTOFILL_TOKENS_ADDRESS.reduce(toExpression),\n            tokensContact = AUTOFILL_TOKENS_CONTACT.reduce(toExpression),\n            fields = AUTOFILL_FIELDS.reduce(toExpression),\n            fieldsContact = AUTOFILL_FIELDS_CONTACT.reduce(toExpression),\n            regex = new RegExp(`^(section-\\\\w+\\\\s{1})?((${tokensAddress}){1}\\\\s)?((${fields}){1}|((${tokensContact}){1}\\\\s{1}(${fieldsContact})))$`);\n\n        return regex.test(tokens);\n    }\n}","import { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\nimport { AUTOCOMPLETE_ON } from \"../utils/autofill.utils\";\n\nexport interface DynamicInputControlModelConfig<T> extends DynamicFormValueControlModelConfig<T> {\n\n    autoComplete?: string;\n    autoFocus?: boolean;\n    maxLength?: number;\n    minLength?: number;\n    placeholder?: string;\n    prefix?: string;\n    readOnly?: boolean;\n    spellCheck?: boolean;\n    suffix?: string;\n}\n\nexport abstract class DynamicInputControlModel<T> extends DynamicFormValueControlModel<T> {\n\n    @serializable() autoComplete: string;\n    @serializable() autoFocus: boolean;\n    @serializable() maxLength: number | null;\n    @serializable() minLength: number | null;\n    @serializable() placeholder: string;\n    @serializable() prefix: string | null;\n    @serializable() readOnly: boolean;\n    @serializable() spellCheck: boolean;\n    @serializable() suffix: string | null;\n\n    constructor(config: DynamicInputControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.autoComplete = config.autoComplete || AUTOCOMPLETE_ON;\n        this.autoFocus = typeof config.autoFocus === \"boolean\" ? config.autoFocus : false;\n        this.maxLength = typeof config.maxLength === \"number\" ? config.maxLength : null;\n        this.minLength = typeof config.minLength === \"number\" ? config.minLength : null;\n        this.placeholder = config.placeholder || \"\";\n        this.prefix = config.prefix || null;\n        this.readOnly = typeof config.readOnly === \"boolean\" ? config.readOnly : false;\n        this.spellCheck = typeof config.spellCheck === \"boolean\" ? config.spellCheck : false;\n        this.suffix = config.suffix || null;\n    }\n}","export class JSONUtils {\n\n    static maskToString(mask: string | RegExp | (string | RegExp)[]): string | string[] | null {\n\n        if (typeof mask === \"string\") {\n\n            return mask as string;\n\n        } else if (mask instanceof RegExp) {\n\n            return mask.toString();\n\n        } else if (Array.isArray(mask)) {\n\n            return mask.map(value => JSONUtils.maskToString(value)) as string[];\n        }\n\n        return null;\n    }\n\n    static maskFromString(mask: string | string[]): string | RegExp | (string | RegExp)[] | null {\n\n        if (typeof mask === \"string\") {\n\n            let isRegExp = (mask as string).startsWith(\"/\") && (mask as string).endsWith(\"/\");\n\n            return isRegExp ? new RegExp((mask as string).slice(1, mask.length - 1)) : mask;\n\n        } else if (Array.isArray(mask)) {\n\n            return (mask as string[]).map(value => JSONUtils.maskFromString(value)) as string[];\n        }\n\n        return null;\n    }\n\n    static parseReviver(_key: string, value: any): any {\n\n        let regexDateISO = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*))(?:Z|(\\+|-)([\\d|:]*))?$/;\n\n        return typeof value === \"string\" && regexDateISO.test(value) ? new Date(value) : value;\n    }\n}","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\nimport { JSONUtils } from \"../../utils/json.utils\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_INPUT = \"INPUT\";\n\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_COLOR = \"color\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATE = \"date\";\n//export const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATETIME = \"datetime\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_DATETIME_LOCAL = \"datetime-local\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_EMAIL = \"email\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE = \"file\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_MONTH = \"month\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_NUMBER = \"number\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_PASSWORD = \"password\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_RANGE = \"range\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_SEARCH = \"search\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEL = \"tel\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEXT = \"text\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_TIME = \"time\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_URL = \"url\";\nexport const DYNAMIC_FORM_CONTROL_INPUT_TYPE_WEEK = \"week\";\n\nexport interface DynamicInputModelConfig extends DynamicInputControlModelConfig<string | number | Date | string[]> {\n\n    accept?: string;\n    inputType?: string;\n    list?: string[];\n    mask?: string | RegExp | (string | RegExp)[];\n    max?: number | string | Date;\n    min?: number | string | Date;\n    multiple?: boolean;\n    pattern?: string;\n    step?: number;\n}\n\nexport class DynamicInputModel extends DynamicInputControlModel<string | number | Date | string[]> {\n\n    @serializable() accept: string | null;\n    @serializable() inputType: string;\n    files: FileList | null = null;\n    @serializable() list: string[] | null;\n    @serializable() mask: string | RegExp | (string | RegExp)[] | null;\n    @serializable() max: number | string | Date | null;\n    @serializable() min: number | string | Date | null;\n    @serializable() multiple: boolean | null;\n    @serializable() pattern: string | null;\n    @serializable() step: number | null;\n\n    private listId: string | null = null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_INPUT;\n\n    constructor(config: DynamicInputModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.accept = config.accept || null;\n        this.inputType = config.inputType || DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEXT;\n        this.list = Array.isArray(config.list) ? config.list : null;\n        this.mask = config.mask || null;\n        this.max = config.max !== undefined ? config.max : null;\n        this.min = config.min !== undefined ? config.min : null;\n        this.multiple = typeof config.multiple === \"boolean\" ? config.multiple : null;\n        this.pattern = config.pattern || null;\n        this.step = typeof config.step === \"number\" ? config.step : null;\n\n        if (this.list) {\n            this.listId = `${this.id}List`;\n        }\n    }\n\n    toJSON() {\n\n        let json: any = super.toJSON();\n\n        if (this.mask !== null) { json.mask = JSONUtils.maskToString(this.mask); }\n\n        return json;\n    }\n}","import { Directive, Input, TemplateRef } from \"@angular/core\";\n\nexport const DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_START = \"START\";\nexport const DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_END = \"END\";\n\n@Directive({\n    selector: \"ng-template[modelId],ng-template[modelType]\"\n})\nexport class DynamicTemplateDirective {\n\n    @Input() align: string = DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_END;\n    @Input() as: string | null = null;\n    @Input() modelId: string;\n    @Input() modelType: string;\n\n    constructor(public templateRef: TemplateRef<any>) {}\n}","import { FormGroup, FormControl } from \"@angular/forms\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport {\n    DynamicFormControlRelation,\n    DynamicFormControlRelationGroup,\n    DYNAMIC_FORM_CONTROL_ACTION_DISABLE,\n    DYNAMIC_FORM_CONTROL_ACTION_ENABLE,\n    DYNAMIC_FORM_CONTROL_CONNECTIVE_AND,\n    DYNAMIC_FORM_CONTROL_CONNECTIVE_OR\n} from \"../model/misc/dynamic-form-control-relation.model\";\n\nexport class RelationUtils {\n\n    static findActivationRelation(relGroups: DynamicFormControlRelationGroup[]): DynamicFormControlRelationGroup | null {\n\n        let rel = relGroups.find(rel => {\n            return rel.action === DYNAMIC_FORM_CONTROL_ACTION_DISABLE || rel.action === DYNAMIC_FORM_CONTROL_ACTION_ENABLE;\n        });\n\n        return rel !== undefined ? rel : null;\n    }\n\n    static getRelatedFormControls(model: DynamicFormControlModel, controlGroup: FormGroup): FormControl[] {\n\n        let controls: FormControl[] = [];\n\n        model.relation.forEach(relGroup => relGroup.when.forEach(rel => {\n\n            if (model.id === rel.id) {\n                throw new Error(`FormControl ${model.id} cannot depend on itself`);\n            }\n\n            let control = controlGroup.get(rel.id) as FormControl;\n\n            if (control && !controls.some(controlElement => controlElement === control)) {\n                controls.push(control);\n            }\n        }));\n\n        return controls;\n    }\n\n    static isFormControlToBeDisabled(relGroup: DynamicFormControlRelationGroup, _formGroup: FormGroup): boolean {\n\n        let formGroup: FormGroup = _formGroup;\n\n        return relGroup.when.reduce((toBeDisabled: boolean, rel: DynamicFormControlRelation, index: number) => {\n\n            let control = formGroup.get(rel.id);\n\n            if (control && relGroup.action === DYNAMIC_FORM_CONTROL_ACTION_DISABLE) {\n\n                if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_AND && !toBeDisabled) {\n                    return false;\n                }\n\n                if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_OR && toBeDisabled) {\n                    return true;\n                }\n\n                return rel.value === control.value || rel.status === control.status;\n            }\n\n            if (control && relGroup.action === DYNAMIC_FORM_CONTROL_ACTION_ENABLE) {\n\n                if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_AND && toBeDisabled) {\n                    return true;\n                }\n\n                if (index > 0 && relGroup.connective === DYNAMIC_FORM_CONTROL_CONNECTIVE_OR && !toBeDisabled) {\n                    return false;\n                }\n\n                return !(rel.value === control.value || rel.status === control.status);\n            }\n\n            return false;\n\n        }, false);\n    }\n}","import { DynamicFormControlValue } from \"../dynamic-form-value-control.model\";\n\nexport const DYNAMIC_FORM_CONTROL_ACTION_DISABLE = \"DISABLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_ENABLE = \"ENABLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_VISIBLE = \"VISIBLE\";\nexport const DYNAMIC_FORM_CONTROL_ACTION_HIDDEN = \"HIDDEN\";\n\nexport const DYNAMIC_FORM_CONTROL_CONNECTIVE_AND = \"AND\";\nexport const DYNAMIC_FORM_CONTROL_CONNECTIVE_OR = \"OR\";\n\nexport interface DynamicFormControlRelation {\n\n    id: string;\n    status?: string;\n    value?: DynamicFormControlValue;\n}\n\nexport interface DynamicFormControlRelationGroup {\n\n    action: string;\n    connective?: string;\n    when: DynamicFormControlRelation[];\n}","import {\n    AfterViewInit,\n    ChangeDetectorRef,\n    EventEmitter,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    QueryList,\n    SimpleChange,\n    SimpleChanges\n} from \"@angular/core\";\nimport { FormControl, FormGroup } from \"@angular/forms\";\nimport { Subscription } from \"rxjs/Subscription\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormValueControlModel, DynamicFormControlValue } from \"../model/dynamic-form-value-control.model\";\nimport {\n    DynamicFormArrayGroupModel,\n    DYNAMIC_FORM_CONTROL_TYPE_ARRAY\n} from \"../model/form-array/dynamic-form-array.model\";\nimport {\n    DynamicInputModel,\n    DYNAMIC_FORM_CONTROL_TYPE_INPUT,\n    DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE\n} from \"../model/input/dynamic-input.model\";\nimport { DynamicFormControlLayout } from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicFormControlRelationGroup } from \"../model/misc/dynamic-form-control-relation.model\";\nimport {\n    DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_END,\n    DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_START,\n    DynamicTemplateDirective\n} from \"../directive/dynamic-template.directive\";\nimport { DynamicFormLayout, DynamicFormLayoutService } from \"../service/dynamic-form-layout.service\";\nimport { DynamicFormValidationService } from \"../service/dynamic-form-validation.service\";\nimport { RelationUtils } from \"../utils/relation.utils\";\n\nexport interface DynamicFormControlEvent {\n\n    $event: Event | FocusEvent | DynamicFormControlEvent | any;\n    context: DynamicFormArrayGroupModel | null;\n    control: FormControl;\n    group: FormGroup;\n    model: DynamicFormControlModel;\n    type: string;\n}\n\nexport const DYNAMIC_FORM_CONTROL_EVENT_TYPE_BLUR = \"blur\";\nexport const DYNAMIC_FORM_CONTROL_EVENT_TYPE_CHANGE = \"change\";\nexport const DYNAMIC_FORM_CONTROL_EVENT_TYPE_FOCUS = \"focus\";\nexport const DYNAMIC_FORM_CONTROL_EVENT_TYPE_CUSTOM = \"custom\";\n\nexport enum DynamicFormControlComponentTemplatePosition {start = 0, end, array}\n\nexport abstract class DynamicFormControlComponent implements OnChanges, OnInit, AfterViewInit, OnDestroy {\n\n    bindId: boolean;\n    context: DynamicFormArrayGroupModel | null;\n    control: FormControl;\n    group: FormGroup;\n    hasErrorMessaging: boolean = false;\n    hasFocus: boolean;\n    layout: DynamicFormLayout;\n    model: DynamicFormControlModel;\n\n    contentTemplateList: QueryList<DynamicTemplateDirective>;\n    inputTemplateList: QueryList<DynamicTemplateDirective> | null = null;\n    templates: DynamicTemplateDirective[] = [];\n\n    blur: EventEmitter<DynamicFormControlEvent>;\n    change: EventEmitter<DynamicFormControlEvent>;\n    focus: EventEmitter<DynamicFormControlEvent>;\n    customEvent: EventEmitter<DynamicFormControlEvent>;\n\n    private subscriptions: Subscription[] = [];\n\n    abstract type: number | string | null;\n\n    constructor(protected changeDetectorRef: ChangeDetectorRef, protected layoutService: DynamicFormLayoutService,\n                protected validationService: DynamicFormValidationService) { }\n\n    ngOnChanges(changes: SimpleChanges) {\n\n        let groupChange = changes[\"group\"] as SimpleChange,\n            modelChange = changes[\"model\"] as SimpleChange;\n\n        if (groupChange || modelChange) {\n\n            if (this.model) {\n\n                this.unsubscribe();\n\n                if (this.group) {\n\n                    this.control = this.group.get(this.model.id) as FormControl;\n                    this.subscriptions.push(this.control.valueChanges.subscribe(value => this.onControlValueChanges(value)));\n                }\n\n                this.subscriptions.push(this.model.disabledUpdates.subscribe(value => this.onModelDisabledUpdates(value)));\n\n                if (this.model instanceof DynamicFormValueControlModel) {\n\n                    let model = this.model as DynamicFormValueControlModel<DynamicFormControlValue>;\n\n                    this.subscriptions.push(model.valueUpdates.subscribe(value => this.onModelValueUpdates(value)));\n                }\n\n                if (this.model.relation.length > 0) {\n                    this.setControlRelations();\n                }\n            }\n        }\n    }\n\n    ngOnInit() {\n\n        if (!this.model && !this.group) {\n            throw new Error(`no [model] or [group] input set for DynamicFormControlComponent`);\n        }\n    }\n\n    ngAfterViewInit() {\n\n        this.setTemplates();\n        this.changeDetectorRef.detectChanges();\n    }\n\n    ngOnDestroy() {\n        this.unsubscribe();\n    }\n\n    get errorMessages(): string[] {\n        return this.validationService.createErrorMessages(this.control, this.model);\n    }\n\n    get showHint(): boolean { // needed for AOT\n        return (this.model as DynamicFormValueControlModel<DynamicFormControlValue>).hint !== null;\n    }\n\n    get hasList(): boolean { // needed for AOT\n        return (this.model as DynamicInputModel).list !== null;\n    }\n\n    get isInvalid(): boolean {\n        return this.control.invalid;\n    }\n\n    get isValid(): boolean {\n        return this.control.valid;\n    }\n\n    get showErrorMessages(): boolean {\n        return this.hasErrorMessaging && this.control.touched && !this.hasFocus && this.isInvalid;\n    }\n\n    get templateList(): QueryList<DynamicTemplateDirective> {\n        return this.inputTemplateList !== null ? this.inputTemplateList : this.contentTemplateList;\n    }\n\n    getClass(context: string, place: string, model: DynamicFormControlModel = this.model): string {\n\n        let controlLayout = (this.layout && this.layout[model.id]) || model.layout as DynamicFormControlLayout;\n\n        return this.layoutService.getClass(controlLayout, context, place);\n    }\n\n    getAdditional(key: string, defaultValue: any = null): any {\n\n        let model = this.model as DynamicFormValueControlModel<DynamicFormControlValue>;\n\n        return model.additional !== null && model.additional.hasOwnProperty(key) ? model.additional[key] : defaultValue;\n    }\n\n    protected createDynamicFormControlEvent($event: any, type: string): DynamicFormControlEvent {\n        return {$event, context: this.context, control: this.control, group: this.group, model: this.model, type};\n    }\n\n    protected setTemplates(): void {\n\n        this.templateList.forEach((template: DynamicTemplateDirective) => {\n\n            if ((template.modelType === this.model.type || template.modelId === this.model.id) && template.as === null) {\n\n                if (this.model.type === DYNAMIC_FORM_CONTROL_TYPE_ARRAY) {\n\n                    this.templates[DynamicFormControlComponentTemplatePosition.array] = template;\n\n                } else if (template.align === DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_START) {\n\n                    this.templates[DynamicFormControlComponentTemplatePosition.start] = template;\n\n                } else if (template.align === DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_END) {\n\n                    this.templates[DynamicFormControlComponentTemplatePosition.end] = template;\n                }\n            }\n        });\n    }\n\n    protected setControlRelations(): void {\n\n        let relActivation = RelationUtils.findActivationRelation(this.model.relation);\n\n        if (relActivation !== null) {\n\n            let rel = relActivation as DynamicFormControlRelationGroup;\n\n            this.updateModelDisabled(rel);\n\n            RelationUtils.getRelatedFormControls(this.model, this.group).forEach(control => {\n\n                this.subscriptions.push(control.valueChanges.subscribe(() => this.updateModelDisabled(rel)));\n                this.subscriptions.push(control.statusChanges.subscribe(() => this.updateModelDisabled(rel)));\n            });\n        }\n    }\n\n    updateModelDisabled(relation: DynamicFormControlRelationGroup): void {\n\n        this.model.disabledUpdates.next(RelationUtils.isFormControlToBeDisabled(relation, this.group));\n    }\n\n    unsubscribe(): void {\n\n        this.subscriptions.forEach(subscription => subscription.unsubscribe());\n        this.subscriptions = [];\n    }\n\n    onControlValueChanges(value: DynamicFormControlValue): void {\n\n        if (this.model instanceof DynamicFormValueControlModel) {\n\n            let model = this.model as DynamicFormValueControlModel<DynamicFormControlValue>;\n\n            if (model.value !== value) {\n                model.valueUpdates.next(value);\n            }\n        }\n    }\n\n    onModelValueUpdates(value: DynamicFormControlValue): void {\n\n        if (this.control.value !== value) {\n            this.control.setValue(value);\n        }\n    }\n\n    onModelDisabledUpdates(value: boolean): void {\n        value ? this.control.disable() : this.control.enable();\n    }\n\n    onValueChange($event: Event | DynamicFormControlEvent | any): void {\n\n        if ($event && $event instanceof Event) { // native HTML5 change event\n\n            if (this.model.type === DYNAMIC_FORM_CONTROL_TYPE_INPUT) {\n\n                let model = this.model as DynamicInputModel;\n\n                if (model.inputType === DYNAMIC_FORM_CONTROL_INPUT_TYPE_FILE) {\n\n                    let inputElement: any = ($event as Event).target || ($event as Event).srcElement;\n\n                    model.files = inputElement.files as FileList;\n                }\n            }\n\n            this.change.emit(this.createDynamicFormControlEvent($event as Event, \"change\"));\n\n        } else if (DynamicFormControlComponent.isDynamicFormControlEvent($event)) { // event bypass\n\n            this.change.emit($event as DynamicFormControlEvent);\n\n        } else { // custom library value change event\n\n            this.change.emit(this.createDynamicFormControlEvent($event, \"change\"));\n        }\n    }\n\n    onBlur($event: FocusEvent | DynamicFormControlEvent | any): void {\n\n        if (DynamicFormControlComponent.isDynamicFormControlEvent($event)) { // event bypass\n\n            this.blur.emit($event as DynamicFormControlEvent);\n\n        } else { // native HTML 5 or UI library blur event\n\n            this.hasFocus = false;\n            this.blur.emit(this.createDynamicFormControlEvent($event, \"blur\"));\n        }\n    }\n\n    onFocus($event: FocusEvent | DynamicFormControlEvent | any): void {\n\n        if (DynamicFormControlComponent.isDynamicFormControlEvent($event)) { // event bypass\n\n            this.focus.emit($event as DynamicFormControlEvent);\n\n        } else { // native HTML 5 or UI library focus event\n\n            this.hasFocus = true;\n            this.focus.emit(this.createDynamicFormControlEvent($event, \"focus\"));\n        }\n    }\n\n    onCustomEvent($event: any, type: string): void {\n\n        if (DynamicFormControlComponent.isDynamicFormControlEvent($event)) { // child event bypass\n\n            this.customEvent.emit($event as DynamicFormControlEvent);\n\n        } else { // native UI library custom event\n\n            this.customEvent.emit(this.createDynamicFormControlEvent($event, type));\n        }\n    }\n\n    static isDynamicFormControlEvent($event: any): boolean {\n        return $event !== null && typeof $event === \"object\" && $event.hasOwnProperty(\"$event\");\n    }\n}","import { EventEmitter, QueryList } from \"@angular/core\";\nimport { FormGroup } from \"@angular/forms\";\nimport {\n    DynamicFormControlComponent,\n    DynamicFormControlEvent,\n    DYNAMIC_FORM_CONTROL_EVENT_TYPE_BLUR,\n    DYNAMIC_FORM_CONTROL_EVENT_TYPE_CHANGE,\n    DYNAMIC_FORM_CONTROL_EVENT_TYPE_FOCUS,\n    DYNAMIC_FORM_CONTROL_EVENT_TYPE_CUSTOM\n} from \"./dynamic-form-control.component\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormControlLayout } from \"../model/misc/dynamic-form-control-layout.model\";\nimport { DynamicTemplateDirective } from \"../directive/dynamic-template.directive\";\nimport { DynamicFormService } from \"../service/dynamic-form.service\";\nimport { DynamicFormLayout, DynamicFormLayoutService } from \"../service/dynamic-form-layout.service\";\n\nexport abstract class DynamicFormComponent {\n\n    formGroup: FormGroup;\n    formModel: DynamicFormControlModel[];\n    formLayout: DynamicFormLayout;\n\n    components: QueryList<DynamicFormControlComponent>;\n    templates: QueryList<DynamicTemplateDirective>;\n\n    blur: EventEmitter<DynamicFormControlEvent>;\n    change: EventEmitter<DynamicFormControlEvent>;\n    focus: EventEmitter<DynamicFormControlEvent>;\n    customEvent: EventEmitter<DynamicFormControlEvent>;\n\n    constructor(protected formService: DynamicFormService, protected layoutService: DynamicFormLayoutService) {}\n\n    trackByFn(_index: number, model: DynamicFormControlModel): string {\n        return model.id;\n    }\n\n    getClass(model: DynamicFormControlModel, context: string, place: string): string {\n\n        let controlLayout = this.layoutService.findById(model.id, this.formLayout) || model.layout as DynamicFormControlLayout;\n\n        return this.layoutService.getClass(controlLayout, context, place);\n    }\n\n    onEvent($event: DynamicFormControlEvent, type: string) {\n\n        switch (type) {\n\n            case DYNAMIC_FORM_CONTROL_EVENT_TYPE_BLUR:\n                this.blur.emit($event);\n                break;\n\n            case DYNAMIC_FORM_CONTROL_EVENT_TYPE_CHANGE:\n                this.change.emit($event);\n                break;\n\n            case DYNAMIC_FORM_CONTROL_EVENT_TYPE_FOCUS:\n                this.focus.emit($event);\n                break;\n\n            case DYNAMIC_FORM_CONTROL_EVENT_TYPE_CUSTOM:\n                this.customEvent.emit($event);\n                break;\n        }\n    }\n}\n","import { Directive, ElementRef, Input, Renderer2, AfterViewInit } from \"@angular/core\";\n\n@Directive({\n    selector: \"[dynamicId]\"\n})\nexport class DynamicIdDirective implements AfterViewInit {\n\n    @Input() dynamicId: string | boolean;\n\n    constructor(private elementRef: ElementRef, private renderer: Renderer2) {}\n\n    ngAfterViewInit() {\n\n        if (this.dynamicId) {\n            this.renderer.setAttribute(this.elementRef.nativeElement, \"id\", this.dynamicId as string);\n        }\n    }\n}","import { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\n\nexport interface DynamicCheckControlModelConfig extends DynamicFormValueControlModelConfig<boolean> {\n\n    labelPosition?: string;\n}\n\nexport abstract class DynamicCheckControlModel extends DynamicFormValueControlModel<boolean> {\n\n    @serializable() labelPosition: string | null;\n\n    constructor(config: DynamicCheckControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.labelPosition = config.labelPosition || null;\n        this.value = typeof this.value === \"boolean\" ? this.value : false;\n    }\n\n    get checked(): boolean {\n        return !!this.value;\n    }\n\n    set checked(checked: boolean) {\n        this.valueUpdates.next(checked);\n    }\n\n    toggle(): void {\n        this.checked = !this.checked;\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\n\nexport type DynamicDateControlValue = string | object | Date;\n\nexport interface DynamicDateControlModelConfig extends DynamicFormValueControlModelConfig<DynamicDateControlValue> {\n\n    format?: string;\n    max?: DynamicDateControlValue;\n    min?: DynamicDateControlValue;\n    placeholder?: string;\n}\n\nexport abstract class DynamicDateControlModel extends DynamicFormValueControlModel<DynamicDateControlValue> {\n\n    @serializable() format: string | null;\n    @serializable() max: DynamicDateControlValue | null;\n    @serializable() min: DynamicDateControlValue | null;\n    @serializable() placeholder: string | null;\n\n    constructor(config: DynamicDateControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.format = config.format || null;\n        this.max = config.max || null;\n        this.min = config.min || null;\n        this.placeholder = config.placeholder || null;\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../decorator/serializable.decorator\";\n\nexport interface DynamicFileControlModelConfig extends DynamicFormValueControlModelConfig<File | File[]> {\n\n    multiple?: boolean;\n}\n\nexport abstract class DynamicFileControlModel extends DynamicFormValueControlModel<File | File[]> {\n\n    @serializable() multiple: boolean;\n\n    constructor(config: DynamicFileControlModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.multiple = typeof config.multiple === \"boolean\" ? config.multiple : false;\n    }\n}","declare let global: any;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\n\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\nconst _root: any = __window || __global || __self;\n\n// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.\n// This is needed when used with angular/tsickle which inserts a goog.module statement.\n// Wrap in IIFE\n(function () {\n  if (!_root) {\n    throw new Error('RxJS could not find any global context (window, self, global)');\n  }\n})();\n\nexport { _root as root };","export function isObject(x: any): x is Object {\n  return x != null && typeof x === 'object';\n}\n","import { errorObject } from './errorObject';\n\nlet tryCatchTarget: Function;\n\nfunction tryCatcher(this: any): any {\n  try {\n    return tryCatchTarget.apply(this, arguments);\n  } catch (e) {\n    errorObject.e = e;\n    return errorObject;\n  }\n}\n\nexport function tryCatch<T extends Function>(fn: T): T {\n  tryCatchTarget = fn;\n  return <any>tryCatcher;\n};\n","/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport class UnsubscriptionError extends Error {\n  constructor(public errors: any[]) {\n    super();\n    const err: any = Error.call(this, errors ?\n      `${errors.length} errors occurred during unsubscription:\n  ${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}` : '');\n    (<any> this).name = err.name = 'UnsubscriptionError';\n    (<any> this).stack = err.stack;\n    (<any> this).message = err.message;\n  }\n}\n","import { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { tryCatch } from './util/tryCatch';\nimport { errorObject } from './util/errorObject';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\n\nexport interface AnonymousSubscription {\n  unsubscribe(): void;\n}\n\nexport type TeardownLogic = AnonymousSubscription | Function | void;\n\nexport interface ISubscription extends AnonymousSubscription {\n  unsubscribe(): void;\n  readonly closed: boolean;\n}\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n *\n * @class Subscription\n */\nexport class Subscription implements ISubscription {\n  public static EMPTY: Subscription = (function(empty: any){\n    empty.closed = true;\n    return empty;\n  }(new Subscription()));\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   * @type {boolean}\n   */\n  public closed: boolean = false;\n\n  protected _parent: Subscription = null;\n  protected _parents: Subscription[] = null;\n  private _subscriptions: ISubscription[] = null;\n\n  /**\n   * @param {function(): void} [unsubscribe] A function describing how to\n   * perform the disposal of resources when the `unsubscribe` method is called.\n   */\n  constructor(unsubscribe?: () => void) {\n    if (unsubscribe) {\n      (<any> this)._unsubscribe = unsubscribe;\n    }\n  }\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   * @return {void}\n   */\n  unsubscribe(): void {\n    let hasErrors = false;\n    let errors: any[];\n\n    if (this.closed) {\n      return;\n    }\n\n    let { _parent, _parents, _unsubscribe, _subscriptions } = (<any> this);\n\n    this.closed = true;\n    this._parent = null;\n    this._parents = null;\n    // null out _subscriptions first so any child subscriptions that attempt\n    // to remove themselves from this subscription will noop\n    this._subscriptions = null;\n\n    let index = -1;\n    let len = _parents ? _parents.length : 0;\n\n    // if this._parent is null, then so is this._parents, and we\n    // don't have to remove ourselves from any parent subscriptions.\n    while (_parent) {\n      _parent.remove(this);\n      // if this._parents is null or index >= len,\n      // then _parent is set to null, and the loop exits\n      _parent = ++index < len && _parents[index] || null;\n    }\n\n    if (isFunction(_unsubscribe)) {\n      let trial = tryCatch(_unsubscribe).call(this);\n      if (trial === errorObject) {\n        hasErrors = true;\n        errors = errors || (\n          errorObject.e instanceof UnsubscriptionError ?\n            flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]\n        );\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n\n      index = -1;\n      len = _subscriptions.length;\n\n      while (++index < len) {\n        const sub = _subscriptions[index];\n        if (isObject(sub)) {\n          let trial = tryCatch(sub.unsubscribe).call(sub);\n          if (trial === errorObject) {\n            hasErrors = true;\n            errors = errors || [];\n            let err = errorObject.e;\n            if (err instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(err.errors));\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n    }\n\n    if (hasErrors) {\n      throw new UnsubscriptionError(errors);\n    }\n  }\n\n  /**\n   * Adds a tear down to be called during the unsubscribe() of this\n   * Subscription.\n   *\n   * If the tear down being added is a subscription that is already\n   * unsubscribed, is the same reference `add` is being called on, or is\n   * `Subscription.EMPTY`, it will not be added.\n   *\n   * If this subscription is already in an `closed` state, the passed\n   * tear down logic will be executed immediately.\n   *\n   * @param {TeardownLogic} teardown The additional logic to execute on\n   * teardown.\n   * @return {Subscription} Returns the Subscription used or created to be\n   * added to the inner subscriptions list. This Subscription can be used with\n   * `remove()` to remove the passed teardown logic from the inner subscriptions\n   * list.\n   */\n  add(teardown: TeardownLogic): Subscription {\n    if (!teardown || (teardown === Subscription.EMPTY)) {\n      return Subscription.EMPTY;\n    }\n\n    if (teardown === this) {\n      return this;\n    }\n\n    let subscription = (<Subscription> teardown);\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(<(() => void) > teardown);\n      case 'object':\n        if (subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (typeof subscription._addParent !== 'function' /* quack quack */) {\n          const tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n        break;\n      default:\n        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n    }\n\n    const subscriptions = this._subscriptions || (this._subscriptions = []);\n\n    subscriptions.push(subscription);\n    subscription._addParent(this);\n\n    return subscription;\n  }\n\n  /**\n   * Removes a Subscription from the internal list of subscriptions that will\n   * unsubscribe during the unsubscribe process of this Subscription.\n   * @param {Subscription} subscription The subscription to remove.\n   * @return {void}\n   */\n  remove(subscription: Subscription): void {\n    const subscriptions = this._subscriptions;\n    if (subscriptions) {\n      const subscriptionIndex = subscriptions.indexOf(subscription);\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  }\n\n  private _addParent(parent: Subscription) {\n    let { _parent, _parents } = this;\n    if (!_parent || _parent === parent) {\n      // If we don't have a parent, or the new parent is the same as the\n      // current parent, then set this._parent to the new parent.\n      this._parent = parent;\n    } else if (!_parents) {\n      // If there's already one parent, but not multiple, allocate an Array to\n      // store the rest of the parent Subscriptions.\n      this._parents = [parent];\n    } else if (_parents.indexOf(parent) === -1) {\n      // Only add the new parent to the _parents list if it's not already there.\n      _parents.push(parent);\n    }\n  }\n}\n\nfunction flattenUnsubscriptionErrors(errors: any[]) {\n return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);\n}\n","export interface NextObserver<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error?: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface ErrorObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error: (err: any) => void;\n  complete?: () => void;\n}\n\nexport interface CompletionObserver<T> {\n  closed?: boolean;\n  next?: (value: T) => void;\n  error?: (err: any) => void;\n  complete: () => void;\n}\n\nexport type PartialObserver<T> = NextObserver<T> | ErrorObserver<T> | CompletionObserver<T>;\n\nexport interface Observer<T> {\n  closed?: boolean;\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\nexport const empty: Observer<any> = {\n  closed: true,\n  next(value: any): void { /* noop */},\n  error(err: any): void { throw err; },\n  complete(): void { /*noop*/ }\n};\n","import { root } from '../util/root';\n\nconst Symbol: any = root.Symbol;\n\nexport const rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?\n  Symbol.for('rxSubscriber') : '@@rxSubscriber';\n\n/**\n * @deprecated use rxSubscriber instead\n */\nexport const $$rxSubscriber = rxSubscriber;\n","import { isFunction } from './util/isFunction';\nimport { Observer, PartialObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { empty as emptyObserver } from './Observer';\nimport { rxSubscriber as rxSubscriberSymbol } from './symbol/rxSubscriber';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n *\n * @class Subscriber<T>\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n\n  [rxSubscriberSymbol]() { return this; }\n\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param {function(x: ?T): void} [next] The `next` callback of an Observer.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   */\n  static create<T>(next?: (x?: T) => void,\n                   error?: (e?: any) => void,\n                   complete?: () => void): Subscriber<T> {\n    const subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  }\n\n  public syncErrorValue: any = null;\n  public syncErrorThrown: boolean = false;\n  public syncErrorThrowable: boolean = false;\n\n  protected isStopped: boolean = false;\n  protected destination: PartialObserver<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @param {Observer|function(value: T): void} [destinationOrNext] A partially\n   * defined Observer or a `next` callback function.\n   * @param {function(e: ?any): void} [error] The `error` callback of an\n   * Observer.\n   * @param {function(): void} [complete] The `complete` callback of an\n   * Observer.\n   */\n  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    switch (arguments.length) {\n      case 0:\n        this.destination = emptyObserver;\n        break;\n      case 1:\n        if (!destinationOrNext) {\n          this.destination = emptyObserver;\n          break;\n        }\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            this.destination = (<Subscriber<any>> destinationOrNext);\n            (<any> this.destination).add(this);\n          } else {\n            this.syncErrorThrowable = true;\n            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);\n          }\n          break;\n        }\n      default:\n        this.syncErrorThrowable = true;\n        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);\n        break;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param {T} [value] The `next` value.\n   * @return {void}\n   */\n  next(value?: T): void {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached {@link Error}. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param {any} [err] The `error` exception.\n   * @return {void}\n   */\n  error(err?: any): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   * @return {void}\n   */\n  complete(): void {\n    if (!this.isStopped) {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (this.closed) {\n      return;\n    }\n    this.isStopped = true;\n    super.unsubscribe();\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    this.destination.error(err);\n    this.unsubscribe();\n  }\n\n  protected _complete(): void {\n    this.destination.complete();\n    this.unsubscribe();\n  }\n\n  protected _unsubscribeAndRecycle(): Subscriber<T> {\n    const { _parent, _parents } = this;\n    this._parent = null;\n    this._parents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parent = _parent;\n    this._parents = _parents;\n    return this;\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass SafeSubscriber<T> extends Subscriber<T> {\n\n  private _context: any;\n\n  constructor(private _parentSubscriber: Subscriber<T>,\n              observerOrNext?: PartialObserver<T> | ((value: T) => void),\n              error?: (e?: any) => void,\n              complete?: () => void) {\n    super();\n\n    let next: ((value: T) => void);\n    let context: any = this;\n\n    if (isFunction(observerOrNext)) {\n      next = (<((value: T) => void)> observerOrNext);\n    } else if (observerOrNext) {\n      next = (<PartialObserver<T>> observerOrNext).next;\n      error = (<PartialObserver<T>> observerOrNext).error;\n      complete = (<PartialObserver<T>> observerOrNext).complete;\n      if (observerOrNext !== emptyObserver) {\n        context = Object.create(observerOrNext);\n        if (isFunction(context.unsubscribe)) {\n          this.add(<() => void> context.unsubscribe.bind(context));\n        }\n        context.unsubscribe = this.unsubscribe.bind(this);\n      }\n    }\n\n    this._context = context;\n    this._next = next;\n    this._error = error;\n    this._complete = complete;\n  }\n\n  next(value?: T): void {\n    if (!this.isStopped && this._next) {\n      const { _parentSubscriber } = this;\n      if (!_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  error(err?: any): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._error) {\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n        throw err;\n      } else {\n        _parentSubscriber.syncErrorValue = err;\n        _parentSubscriber.syncErrorThrown = true;\n        this.unsubscribe();\n      }\n    }\n  }\n\n  complete(): void {\n    if (!this.isStopped) {\n      const { _parentSubscriber } = this;\n      if (this._complete) {\n        const wrappedComplete = () => this._complete.call(this._context);\n\n        if (!_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  }\n\n  private __tryOrUnsub(fn: Function, value?: any): void {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n      throw err;\n    }\n  }\n\n  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      parent.syncErrorValue = err;\n      parent.syncErrorThrown = true;\n      return true;\n    }\n    return false;\n  }\n\n  protected _unsubscribe(): void {\n    const { _parentSubscriber } = this;\n    this._context = null;\n    this._parentSubscriber = null;\n    _parentSubscriber.unsubscribe();\n  }\n}\n","import { root } from '../util/root';\n\nexport function getSymbolObservable(context: any) {\n  let $$observable: any;\n  let Symbol = context.Symbol;\n\n  if (typeof Symbol === 'function') {\n    if (Symbol.observable) {\n      $$observable = Symbol.observable;\n    } else {\n        $$observable = Symbol('observable');\n        Symbol.observable = $$observable;\n    }\n  } else {\n    $$observable = '@@observable';\n  }\n\n  return $$observable;\n}\n\nexport const observable = getSymbolObservable(root);\n\n/**\n * @deprecated use observable instead\n */\nexport const $$observable = observable;\n","import { PartialObserver } from './Observer';\nimport { Operator } from './Operator';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, AnonymousSubscription, TeardownLogic } from './Subscription';\nimport { root } from './util/root';\nimport { toSubscriber } from './util/toSubscriber';\nimport { IfObservable } from './observable/IfObservable';\nimport { ErrorObservable } from './observable/ErrorObservable';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { OperatorFunction } from './interfaces';\nimport { pipeFromArray } from './util/pipe';\n\nexport interface Subscribable<T> {\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): AnonymousSubscription;\n}\n\nexport type SubscribableOrPromise<T> = Subscribable<T> | PromiseLike<T>;\nexport type ObservableInput<T> = SubscribableOrPromise<T> | ArrayLike<T>;\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n *\n * @class Observable<T>\n */\nexport class Observable<T> implements Subscribable<T> {\n\n  public _isScalar: boolean = false;\n\n  protected source: Observable<any>;\n  protected operator: Operator<any, T>;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe the function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new cold Observable by calling the Observable constructor\n   * @static true\n   * @owner Observable\n   * @method create\n   * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor\n   * @return {Observable} a new cold observable\n   */\n  static create: Function = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  }\n\n  /**\n   * Creates a new Observable, with this Observable as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @method lift\n   * @param {Operator} operator the operator defining the operation to take on the observable\n   * @return {Observable} a new observable with the Operator applied\n   */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observer?: PartialObserver<T>): Subscription;\n  subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to a {@link create} static factory, but most of the time it is\n   * a library implementation, which defines what and when will be emitted by an Observable. This means that calling\n   * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will\n   * be left uncaught.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent\n   * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,\n   * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.\n   *\n   * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.\n   *\n   * @example <caption>Subscribe with an Observer</caption>\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() { // We actually could just remove this method,\n   *   },        // since we do not really care about errors right now.\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   * .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Subscribe with functions</caption>\n   * let sum = 0;\n   *\n   * Rx.Observable.of(1, 2, 3)\n   * .subscribe(\n   *   function(value) {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   function() {\n   *     console.log('Sum equals: ' + sum);\n   *   }\n   * );\n   *\n   * // Logs:\n   * // \"Adding: 1\"\n   * // \"Adding: 2\"\n   * // \"Adding: 3\"\n   * // \"Sum equals: 6\"\n   *\n   *\n   * @example <caption>Cancel a subscription</caption>\n   * const subscription = Rx.Observable.interval(1000).subscribe(\n   *   num => console.log(num),\n   *   undefined,\n   *   () => console.log('completed!') // Will not be called, even\n   * );                                // when cancelling subscription\n   *\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // \"unsubscribed!\" after 2.5s\n   *\n   *\n   * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,\n   *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed\n   *  Observable.\n   * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,\n   *  the error will be thrown as unhandled.\n   * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.\n   * @return {ISubscription} a subscription reference to the registered handlers\n   * @method subscribe\n   */\n  subscribe(observerOrNext?: PartialObserver<T> | ((value: T) => void),\n            error?: (error: any) => void,\n            complete?: () => void): Subscription {\n\n    const { operator } = this;\n    const sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      operator.call(sink, this.source);\n    } else {\n      sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (sink.syncErrorThrowable) {\n      sink.syncErrorThrowable = false;\n      if (sink.syncErrorThrown) {\n        throw sink.syncErrorValue;\n      }\n    }\n\n    return sink;\n  }\n\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.syncErrorThrown = true;\n      sink.syncErrorValue = err;\n      sink.error(err);\n    }\n  }\n\n  /**\n   * @method forEach\n   * @param {Function} next a handler for each value emitted by the observable\n   * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise\n   * @return {Promise} a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   */\n  forEach(next: (value: T) => void, PromiseCtor?: typeof Promise): Promise<void> {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor<void>((resolve, reject) => {\n      // Must be declared in a separate statement to avoid a RefernceError when\n      // accessing subscription below in the closure due to Temporal Dead Zone.\n      let subscription: Subscription;\n      subscription = this.subscribe((value) => {\n        if (subscription) {\n          // if there is a subscription, then we can surmise\n          // the next handling is asynchronous. Any errors thrown\n          // need to be rejected explicitly and unsubscribe must be\n          // called manually\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscription.unsubscribe();\n          }\n        } else {\n          // if there is NO subscription, then we're getting a nexted\n          // value synchronously during subscription. We can just call it.\n          // If it errors, Observable's `subscribe` will ensure the\n          // unsubscription logic is called, then synchronously rethrow the error.\n          // After that, Promise will trap the error and send it\n          // down the rejection path.\n          next(value);\n        }\n      }, reject, resolve);\n    });\n  }\n\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source.subscribe(subscriber);\n  }\n\n  // `if` and `throw` are special snow flakes, the compiler sees them as reserved words\n  static if: typeof IfObservable.create;\n  static throw: typeof ErrorObservable.create;\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @method Symbol.observable\n   * @return {Observable} this instance of the observable\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>\n  pipe<A, B, C, D>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>): Observable<D>\n  pipe<A, B, C, D, E>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>): Observable<E>\n  pipe<A, B, C, D, E, F>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>): Observable<F>\n  pipe<A, B, C, D, E, F, G>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>): Observable<G>\n  pipe<A, B, C, D, E, F, G, H>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>): Observable<H>\n  pipe<A, B, C, D, E, F, G, H, I>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>, op4: OperatorFunction<C, D>, op5: OperatorFunction<D, E>, op6: OperatorFunction<E, F>, op7: OperatorFunction<F, G>, op8: OperatorFunction<G, H>, op9: OperatorFunction<H, I>): Observable<I>\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   * @method pipe\n   * @return {Observable} the Observable result of all of the operators having\n   * been called in the order they were passed in.\n   *\n   * @example\n   *\n   * import { map, filter, scan } from 'rxjs/operators';\n   *\n   * Rx.Observable.interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x))\n   */\n  pipe<R>(...operations: OperatorFunction<T, R>[]): Observable<R> {\n    if (operations.length === 0) {\n      return this as any;\n    }\n\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  toPromise<T>(this: Observable<T>): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: typeof Promise): Promise<T>;\n  toPromise<T>(this: Observable<T>, PromiseCtor: PromiseConstructorLike): Promise<T>;\n  /* tslint:enable:max-line-length */\n\n  toPromise(PromiseCtor?: PromiseConstructorLike) {\n    if (!PromiseCtor) {\n      if (root.Rx && root.Rx.config && root.Rx.config.Promise) {\n        PromiseCtor = root.Rx.config.Promise;\n      } else if (root.Promise) {\n        PromiseCtor = root.Promise;\n      }\n    }\n\n    if (!PromiseCtor) {\n      throw new Error('no Promise impl found');\n    }\n\n    return new PromiseCtor((resolve, reject) => {\n      let value: any;\n      this.subscribe((x: T) => value = x, (err: any) => reject(err), () => resolve(value));\n    }) as Promise<T>;\n  }\n}\n","import { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { PartialObserver, empty as emptyObserver } from '../Observer';\n\nexport function toSubscriber<T>(\n  nextOrObserver?: PartialObserver<T> | ((value: T) => void),\n  error?: (error: any) => void,\n  complete?: () => void): Subscriber<T> {\n\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return (<Subscriber<T>> nextOrObserver);\n    }\n\n    if (nextOrObserver[rxSubscriberSymbol]) {\n      return nextOrObserver[rxSubscriberSymbol]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(emptyObserver);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n","import { noop } from './noop';\nimport { UnaryFunction } from '../interfaces';\n\n/* tslint:disable:max-line-length */\nexport function pipe<T>(): UnaryFunction<T, T>;\nexport function pipe<T, A>(op1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(op1: UnaryFunction<T, A>, op2: UnaryFunction<A, B>, op3: UnaryFunction<B, C>, op4: UnaryFunction<C, D>, op5: UnaryFunction<D, E>, op6: UnaryFunction<E, F>, op7: UnaryFunction<F, G>, op8: UnaryFunction<G, H>, op9: UnaryFunction<H, I>): UnaryFunction<T, I>;\n/* tslint:enable:max-line-length */\n\nexport function pipe<T, R>(...fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  return pipeFromArray(fns);\n}\n\n/* @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (!fns) {\n    return noop as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input);\n  };\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ScalarObservable<T> extends Observable<T> {\n  static create<T>(value: T, scheduler?: IScheduler): ScalarObservable<T> {\n    return new ScalarObservable(value, scheduler);\n  }\n\n  static dispatch(state: any): void {\n    const { done, value, subscriber } = state;\n\n    if (done) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(value);\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.done = true;\n    (<any> this).schedule(state);\n  }\n\n  _isScalar: boolean = true;\n\n  constructor(public value: T, private scheduler?: IScheduler) {\n    super();\n    if (scheduler) {\n      this._isScalar = false;\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    const value = this.value;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ScalarObservable.dispatch, 0, {\n        done: false, value, subscriber\n      });\n    } else {\n      subscriber.next(value);\n      if (!subscriber.closed) {\n        subscriber.complete();\n      }\n    }\n  }\n}\n","import { IScheduler } from '../Scheduler';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { TeardownLogic } from '../Subscription';\n\nexport interface DispatchArg<T> {\n  subscriber: Subscriber<T>;\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class EmptyObservable<T> extends Observable<T> {\n\n  /**\n   * Creates an Observable that emits no items to the Observer and immediately\n   * emits a complete notification.\n   *\n   * <span class=\"informal\">Just emits 'complete', and nothing else.\n   * </span>\n   *\n   * <img src=\"./img/empty.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the complete notification. It can be used for composing with other\n   * Observables, such as in a {@link mergeMap}.\n   *\n   * @example <caption>Emit the number 7, then complete.</caption>\n   * var result = Rx.Observable.empty().startWith(7);\n   * result.subscribe(x => console.log(x));\n   *\n   * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>\n   * var interval = Rx.Observable.interval(1000);\n   * var result = interval.mergeMap(x =>\n   *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()\n   * );\n   * result.subscribe(x => console.log(x));\n   *\n   * // Results in the following to the console:\n   * // x is equal to the count on the interval eg(0,1,2,3,...)\n   * // x will occur every 1000ms\n   * // if x % 2 is equal to 1 print abc\n   * // if x % 2 is not equal to 1 nothing will be output\n   *\n   * @see {@link create}\n   * @see {@link never}\n   * @see {@link of}\n   * @see {@link throw}\n   *\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emission of the complete notification.\n   * @return {Observable} An \"empty\" Observable: emits only the complete\n   * notification.\n   * @static true\n   * @name empty\n   * @owner Observable\n   */\n  static create<T>(scheduler?: IScheduler): Observable<T> {\n    return new EmptyObservable<T>(scheduler);\n  }\n\n  static dispatch<T>(arg: DispatchArg<T>) {\n    const { subscriber } = arg;\n    subscriber.complete();\n  }\n\n  constructor(private scheduler?: IScheduler) {\n    super();\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber });\n    } else {\n      subscriber.complete();\n    }\n  }\n}\n","import { Scheduler } from '../Scheduler';\nexport function isScheduler(value: any): value is Scheduler {\n  return value && typeof (<any>value).schedule === 'function';\n}\n","import { IScheduler } from '../Scheduler';\nimport { Observable } from '../Observable';\nimport { ScalarObservable } from './ScalarObservable';\nimport { EmptyObservable } from './EmptyObservable';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nimport { TeardownLogic } from '../Subscription';\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class ArrayObservable<T> extends Observable<T> {\n\n  static create<T>(array: T[], scheduler?: IScheduler): Observable<T> {\n    return new ArrayObservable(array, scheduler);\n  }\n\n  static of<T>(item1: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(item1: T, item2: T, item3: T, item4: T, item5: T, item6: T, scheduler?: IScheduler): Observable<T>;\n  static of<T>(...array: Array<T | IScheduler>): Observable<T>;\n  /**\n   * Creates an Observable that emits some values you specify as arguments,\n   * immediately one after the other, and then emits a complete notification.\n   *\n   * <span class=\"informal\">Emits the arguments you provide, then completes.\n   * </span>\n   *\n   * <img src=\"./img/of.png\" width=\"100%\">\n   *\n   * This static operator is useful for creating a simple Observable that only\n   * emits the arguments given, and the complete notification thereafter. It can\n   * be used for composing with other Observables, such as with {@link concat}.\n   * By default, it uses a `null` IScheduler, which means the `next`\n   * notifications are sent synchronously, although with a different IScheduler\n   * it is possible to determine when those notifications will be delivered.\n   *\n   * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>\n   * var numbers = Rx.Observable.of(10, 20, 30);\n   * var letters = Rx.Observable.of('a', 'b', 'c');\n   * var interval = Rx.Observable.interval(1000);\n   * var result = numbers.concat(letters).concat(interval);\n   * result.subscribe(x => console.log(x));\n   *\n   * @see {@link create}\n   * @see {@link empty}\n   * @see {@link never}\n   * @see {@link throw}\n   *\n   * @param {...T} values Arguments that represent `next` values to be emitted.\n   * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling\n   * the emissions of the `next` notifications.\n   * @return {Observable<T>} An Observable that emits each given input value.\n   * @static true\n   * @name of\n   * @owner Observable\n   */\n  static of<T>(...array: Array<T | IScheduler>): Observable<T> {\n    let scheduler = <IScheduler>array[array.length - 1];\n    if (isScheduler(scheduler)) {\n      array.pop();\n    } else {\n      scheduler = null;\n    }\n\n    const len = array.length;\n    if (len > 1) {\n      return new ArrayObservable<T>(<any>array, scheduler);\n    } else if (len === 1) {\n      return new ScalarObservable<T>(<any>array[0], scheduler);\n    } else {\n      return new EmptyObservable<T>(scheduler);\n    }\n  }\n\n  static dispatch(state: any) {\n\n    const { array, index, count, subscriber } = state;\n\n    if (index >= count) {\n      subscriber.complete();\n      return;\n    }\n\n    subscriber.next(array[index]);\n\n    if (subscriber.closed) {\n      return;\n    }\n\n    state.index = index + 1;\n\n    (<any> this).schedule(state);\n  }\n\n  // value used if Array has one value and _isScalar\n  value: any;\n\n  constructor(private array: T[], private scheduler?: IScheduler) {\n    super();\n    if (!scheduler && array.length === 1) {\n      this._isScalar = true;\n      this.value = array[0];\n    }\n  }\n\n  protected _subscribe(subscriber: Subscriber<T>): TeardownLogic {\n    let index = 0;\n    const array = this.array;\n    const count = array.length;\n    const scheduler = this.scheduler;\n\n    if (scheduler) {\n      return scheduler.schedule(ArrayObservable.dispatch, 0, {\n        array, index, count, subscriber\n      });\n    } else {\n      for (let i = 0; i < count && !subscriber.closed; i++) {\n        subscriber.next(array[i]);\n      }\n      subscriber.complete();\n    }\n  }\n}\n","export class MapPolyfill {\n  public size = 0;\n  private _values: any[] = [];\n  private _keys: any[] = [];\n\n  get(key: any) {\n    const i = this._keys.indexOf(key);\n    return i === -1 ? undefined : this._values[i];\n  }\n\n  set(key: any, value: any) {\n    const i = this._keys.indexOf(key);\n    if (i === -1) {\n      this._keys.push(key);\n      this._values.push(value);\n      this.size++;\n    } else {\n      this._values[i] = value;\n    }\n    return this;\n  }\n\n  delete(key: any): boolean {\n    const i = this._keys.indexOf(key);\n    if (i === -1) { return false; }\n    this._values.splice(i, 1);\n    this._keys.splice(i, 1);\n    this.size--;\n    return true;\n  }\n\n  clear(): void {\n    this._keys.length = 0;\n    this._values.length = 0;\n    this.size = 0;\n  }\n\n  forEach(cb: Function, thisArg: any): void {\n    for (let i = 0; i < this.size; i++) {\n      cb.call(thisArg, this._values[i], this._keys[i]);\n    }\n  }\n}","import { Operator } from '../Operator';\nimport { Subscriber } from '../Subscriber';\nimport { Observable } from '../Observable';\nimport { OperatorFunction } from '../interfaces';\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * <img src=\"./img/map.png\" width=\"100%\">\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * @example <caption>Map every click to the clientX position of that click</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var positions = clicks.map(ev => ev.clientX);\n * positions.subscribe(x => console.log(x));\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param {function(value: T, index: number): R} project The function to apply\n * to each `value` emitted by the source Observable. The `index` parameter is\n * the number `i` for the i-th emission that has happened since the\n * subscription, starting from the number `0`.\n * @param {any} [thisArg] An optional argument to define what `this` is in the\n * `project` function.\n * @return {Observable<R>} An Observable that emits the values from the source\n * Observable transformed by the given `project` function.\n * @method map\n * @owner Observable\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return function mapOperation(source: Observable<T>): Observable<R> {\n    if (typeof project !== 'function') {\n      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n    }\n    return source.lift(new MapOperator(project, thisArg));\n  };\n}\n\nexport class MapOperator<T, R> implements Operator<T, R> {\n  constructor(private project: (value: T, index: number) => R, private thisArg: any) {\n  }\n\n  call(subscriber: Subscriber<R>, source: any): any {\n    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n  }\n}\n\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass MapSubscriber<T, R> extends Subscriber<T> {\n  count: number = 0;\n  private thisArg: any;\n\n  constructor(destination: Subscriber<R>,\n              private project: (value: T, index: number) => R,\n              thisArg: any) {\n    super(destination);\n    this.thisArg = thisArg || this;\n  }\n\n  // NOTE: This looks unoptimized, but it's actually purposefully NOT\n  // using try/catch optimizations.\n  protected _next(value: T) {\n    let result: any;\n    try {\n      result = this.project.call(this.thisArg, value, this.count++);\n    } catch (err) {\n      this.destination.error(err);\n      return;\n    }\n    this.destination.next(result);\n  }\n}\n","import { Observable } from \"rxjs/Observable\";\nimport { of } from \"rxjs/observable/of\";\nimport { map } from \"rxjs/operators\";\nimport { DynamicFormValueControlModel, DynamicFormValueControlModelConfig } from \"./dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"./misc/dynamic-form-control-layout.model\";\nimport { serializable, serialize } from \"../decorator/serializable.decorator\";\n\nexport interface DynamicFormOptionConfig<T> {\n\n    disabled?: boolean;\n    label?: string;\n    value: T;\n}\n\nexport class DynamicFormOption<T> {\n\n    @serializable() disabled: boolean;\n    @serializable() label: string | null;\n    @serializable() value: T;\n\n    constructor(config: DynamicFormOptionConfig<T>) {\n\n        this.disabled = typeof config.disabled === \"boolean\" ? config.disabled : false;\n        this.label = config.label || null;\n        this.value = config.value;\n    }\n\n    get text() {\n        return this.label;\n    }\n\n    set text(text: string | null) {\n        this.label = text;\n    }\n\n    toJSON() {\n        return serialize(this);\n    }\n}\n\nexport interface DynamicOptionControlModelConfig<T> extends DynamicFormValueControlModelConfig<T | T[]> {\n\n    options?: DynamicFormOptionConfig<T>[] | Observable<DynamicFormOptionConfig<T>[]>;\n}\n\nexport abstract class DynamicOptionControlModel<T> extends DynamicFormValueControlModel<T | T[]> {\n\n    @serializable(\"options\") _options: DynamicFormOption<T>[] = [];\n    options$: Observable<DynamicFormOption<T>[]>;\n\n    constructor(config: DynamicOptionControlModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.options = config.options;\n    }\n\n    private updateOptions$(): void {\n        this.options$ = of(this.options);\n    }\n\n    set options(options: any) {\n\n        if (Array.isArray(options)) {\n\n            this._options = (options as DynamicFormOptionConfig<T>[]).map(optionConfig => {\n                return new DynamicFormOption<T>(optionConfig);\n            });\n\n            this.updateOptions$();\n\n        } else if (options instanceof Observable) {\n\n            this.options$ = (options as Observable<DynamicFormOptionConfig<T>[]>).pipe(\n                map(optionsConfig => {\n\n                    let options = optionsConfig.map(optionConfig => new DynamicFormOption<T>(optionConfig));\n                    this._options = options;\n\n                    return options;\n                }));\n\n        } else {\n\n            this.updateOptions$();\n        }\n    }\n\n    get options(): any {\n        return this._options;\n    }\n\n    add(optionConfig: DynamicFormOptionConfig<T>): DynamicFormOption<T> {\n        return this.insert(this.options.length, optionConfig);\n    }\n\n    get(index: number): DynamicFormOption<T> {\n        return this.options[index];\n    }\n\n    insert(index: number, optionConfig: DynamicFormOptionConfig<T>): DynamicFormOption<T> {\n\n        let option = new DynamicFormOption(optionConfig);\n\n        this.options.splice(index, 0, option);\n        this.updateOptions$();\n\n        return option;\n    }\n\n    remove(...indices: number[]): void {\n\n        indices.forEach(index => this.options.splice(index, 1));\n        this.updateOptions$();\n    }\n\n    abstract select(...indices: number[]): void;\n}","import { DynamicCheckControlModel, DynamicCheckControlModelConfig } from \"../dynamic-check-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX = \"CHECKBOX\";\n\nexport interface DynamicCheckboxModelConfig extends DynamicCheckControlModelConfig {\n\n    indeterminate?: boolean;\n}\n\nexport class DynamicCheckboxModel extends DynamicCheckControlModel {\n\n    @serializable() indeterminate: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX;\n\n    constructor(config: DynamicCheckboxModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.indeterminate = typeof config.indeterminate === \"boolean\" ? config.indeterminate : false;\n    }\n}","import { DynamicFormControlModel, DynamicFormControlModelConfig } from \"../dynamic-form-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_GROUP = \"GROUP\";\n\nexport interface DynamicFormGroupModelConfig extends DynamicFormControlModelConfig {\n\n    group?: DynamicFormControlModel[];\n    legend?: string;\n}\n\nexport class DynamicFormGroupModel extends DynamicFormControlModel {\n\n    @serializable() group: DynamicFormControlModel[] = [];\n    @serializable() legend: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_GROUP;\n\n    constructor(config: DynamicFormGroupModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.group = Array.isArray(config.group) ? config.group : [];\n        this.legend = config.legend || null;\n    }\n\n    get(index: number): DynamicFormControlModel {\n        return this.group[index];\n    }\n\n    set(index: number, controlModel: DynamicFormControlModel,): void {\n        this.group[index] = controlModel;\n    }\n\n    add(controlModel: DynamicFormControlModel): void {\n        this.group.push(controlModel);\n    }\n\n    insert(index: number, controlModel: DynamicFormControlModel): void {\n        this.group.splice(index, 0, controlModel);\n    }\n\n    move(index: number, step: number): void {\n        this.group.splice(index + step, 0, ...this.group.splice(index, 1));\n    }\n\n    remove(index: number) {\n        this.group.splice(index, 1);\n    }\n\n    size(): number {\n        return this.group.length;\n    }\n}","import { DynamicFormGroupModel, DynamicFormGroupModelConfig } from \"../form-group/dynamic-form-group.model\";\nimport { DynamicCheckboxModel } from \"./dynamic-checkbox.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP = \"CHECKBOX_GROUP\";\n\nexport class DynamicCheckboxGroupModel extends DynamicFormGroupModel {\n\n    @serializable() group: DynamicCheckboxModel[];\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP;\n\n    constructor(config: DynamicFormGroupModelConfig, layout?: DynamicFormControlLayout) {\n        super(config, layout);\n    }\n\n    check(...indices: number[]): void {\n        indices.forEach(index => this.group[index].checked = true);\n    }\n\n    uncheck(...indices: number[]): void {\n        indices.forEach(index => this.group[index].checked = false);\n    }\n\n    checkAll(): void {\n        this.group.forEach(model => model.checked = true);\n    }\n\n    uncheckAll(): void {\n        this.group.forEach(model => model.checked = false);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER = \"COLORPICKER\";\n\nexport interface DynamicColorPickerModelConfig extends DynamicFormValueControlModelConfig<string | object> {\n\n    format?: string;\n    inline?: boolean;\n}\n\nexport class DynamicColorPickerModel extends DynamicFormValueControlModel<string | object> {\n\n    @serializable() format: string | null;\n    @serializable() inline: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER;\n\n    constructor(config: DynamicColorPickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.format = typeof config.format === \"string\" ? config.format : null;\n        this.inline = typeof config.inline === \"boolean\" ? config.inline : false;\n    }\n}","import {\n    DynamicDateControlModel,\n    DynamicDateControlModelConfig,\n    DynamicDateControlValue\n} from \"../dynamic-date-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER = \"DATEPICKER\";\n\nexport interface DynamicDatePickerModelConfig extends DynamicDateControlModelConfig {\n\n    focusedDate?: DynamicDateControlValue;\n    inline?: boolean;\n    toggleIcon?: string;\n    toggleLabel?: string;\n}\n\nexport class DynamicDatePickerModel extends DynamicDateControlModel {\n\n    @serializable() focusedDate: DynamicDateControlValue | null;\n    @serializable() inline: boolean;\n    @serializable() toggleIcon: string | null;\n    @serializable() toggleLabel: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER;\n\n    constructor(config: DynamicDatePickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.focusedDate = config.focusedDate || null;\n        this.inline = typeof config.inline === \"boolean\" ? config.inline : false;\n        this.toggleIcon = typeof config.toggleIcon === \"string\" ? config.toggleIcon : null;\n        this.toggleLabel = typeof config.toggleLabel === \"string\" ? config.toggleLabel : null;\n    }\n}","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_EDITOR = \"EDITOR\";\n\nexport interface DynamicEditorModelConfig extends DynamicInputControlModelConfig<string> {\n}\n\nexport class DynamicEditorModel extends DynamicInputControlModel<string> {\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_EDITOR;\n\n    constructor(config: DynamicEditorModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n    }\n}","import { DynamicFileControlModelConfig, DynamicFileControlModel } from \"../dynamic-file-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD = \"FILE_UPLOAD\";\n\nexport interface DynamicFileUploadModelConfig extends DynamicFileControlModelConfig {\n\n    accept?: string[];\n    autoUpload?: boolean;\n    maxSize?: number;\n    minSize?: number;\n    removeUrl?: string;\n    showFileList?: boolean;\n    url?: string;\n}\n\nexport class DynamicFileUploadModel extends DynamicFileControlModel {\n\n    @serializable() accept: string[] | null;\n    @serializable() autoUpload: boolean;\n    @serializable() maxSize: number | null;\n    @serializable() minSize: number | null;\n    @serializable() removeUrl: string | null;\n    @serializable() showFileList: boolean;\n    @serializable() url: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD;\n\n    constructor(config: DynamicFileUploadModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.accept = Array.isArray(config.accept) ? config.accept : null;\n        this.autoUpload = typeof config.autoUpload === \"boolean\" ? config.autoUpload : true;\n        this.maxSize = typeof config.maxSize === \"number\" ? config.maxSize : null;\n        this.minSize = typeof config.minSize === \"number\" ? config.minSize : null;\n        this.removeUrl = config.removeUrl || null;\n        this.showFileList = typeof config.showFileList === \"boolean\" ? config.showFileList : true;\n        this.url = config.url || null;\n    }\n}","import { DynamicOptionControlModel, DynamicOptionControlModelConfig } from \"../dynamic-option-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP = \"RADIO_GROUP\";\n\nexport interface DynamicRadioGroupModelConfig<T> extends DynamicOptionControlModelConfig<T> {\n\n    legend?: string;\n}\n\nexport class DynamicRadioGroupModel<T> extends DynamicOptionControlModel<T> {\n\n    @serializable() legend: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP;\n\n    constructor(config: DynamicRadioGroupModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.legend = config.legend || null;\n    }\n\n    select(index: number): void {\n        this.valueUpdates.next(this.get(index).value);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_RATING = \"RATING\";\n\nexport interface DynamicRatingModelConfig extends DynamicFormValueControlModelConfig<number> {\n\n    max?: number;\n}\n\nexport class DynamicRatingModel extends DynamicFormValueControlModel<number> {\n\n    @serializable() max: number | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_RATING;\n\n    constructor(config: DynamicRatingModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.max = typeof config.max === \"number\" ? config.max : 10;\n    }\n}","import { DynamicOptionControlModel, DynamicOptionControlModelConfig } from \"../dynamic-option-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SELECT = \"SELECT\";\n\nexport interface DynamicSelectModelConfig<T> extends DynamicOptionControlModelConfig<T> {\n\n    filterable?: boolean;\n    multiple?: boolean;\n    placeholder?: string;\n}\n\nexport class DynamicSelectModel<T> extends DynamicOptionControlModel<T> {\n\n    @serializable() filterable: boolean;\n    @serializable() multiple: boolean;\n    @serializable() placeholder: string;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SELECT;\n\n    constructor(config: DynamicSelectModelConfig<T>, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.filterable = typeof config.filterable === \"boolean\" ? config.filterable : false;\n        this.multiple = typeof config.multiple === \"boolean\" ? config.multiple : false;\n        this.placeholder = config.placeholder || \"\";\n    }\n\n    select(...indices: number[]): void {\n\n        let value = this.multiple ? indices.map(index => this.get(index).value) : this.get(indices[0]).value;\n\n        this.valueUpdates.next(value);\n    }\n}","import { DynamicFormValueControlModelConfig, DynamicFormValueControlModel } from \"../dynamic-form-value-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SLIDER = \"SLIDER\";\n\nexport interface DynamicSliderModelConfig extends DynamicFormValueControlModelConfig<number> {\n\n    max?: number;\n    min?: number;\n    step?: number;\n    vertical?: boolean;\n}\n\nexport class DynamicSliderModel extends DynamicFormValueControlModel<number> {\n\n    @serializable() max: number | null;\n    @serializable() min: number | null;\n    @serializable() step: number | null;\n    @serializable() vertical: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SLIDER;\n\n    constructor(config: DynamicSliderModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.max = typeof config.max === \"number\" ? config.max : 10;\n        this.min = typeof config.min === \"number\" ? config.min : 0;\n        this.step = typeof config.step === \"number\" ? config.step : 1;\n        this.vertical = typeof config.vertical === \"boolean\" ? config.vertical : false;\n    }\n}","import { DynamicCheckControlModel, DynamicCheckControlModelConfig } from \"../dynamic-check-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_SWITCH = \"SWITCH\";\n\nexport interface DynamicSwitchModelConfig extends DynamicCheckControlModelConfig {\n\n    offLabel?: string;\n    onLabel?: string;\n}\n\nexport class DynamicSwitchModel extends DynamicCheckControlModel {\n\n    @serializable() offLabel: string | null;\n    @serializable() onLabel: string | null;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_SWITCH;\n\n    constructor(config: DynamicSwitchModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.offLabel = config.offLabel || null;\n        this.onLabel = config.onLabel || null;\n    }\n}","import { DynamicInputControlModel, DynamicInputControlModelConfig } from \"../dynamic-input-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA = \"TEXTAREA\";\n\nexport const DYNAMIC_FORM_TEXTAREA_WRAP_HARD = \"hard\";\nexport const DYNAMIC_FORM_TEXTAREA_WRAP_SOFT = \"soft\";\n\nexport interface DynamicTextAreaModelConfig extends DynamicInputControlModelConfig<string> {\n\n    cols?: number;\n    rows?: number;\n    wrap?: string;\n}\n\nexport class DynamicTextAreaModel extends DynamicInputControlModel<string> {\n\n    @serializable() cols: number;\n    @serializable() rows: number;\n    @serializable() wrap: string;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA;\n\n    constructor(config: DynamicTextAreaModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.cols = typeof config.cols === \"number\" ? config.cols : 20;\n        this.rows = typeof config.rows === \"number\" ? config.rows : 2;\n        this.wrap = config.wrap || DYNAMIC_FORM_TEXTAREA_WRAP_SOFT;\n    }\n}","import { DynamicDateControlModel, DynamicDateControlModelConfig } from \"../dynamic-date-control.model\";\nimport { DynamicFormControlLayout } from \"../misc/dynamic-form-control-layout.model\";\nimport { serializable } from \"../../decorator/serializable.decorator\";\n\nexport const DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER = \"TIMEPICKER\";\n\nexport interface DynamicTimePickerModelConfig extends DynamicDateControlModelConfig {\n\n    meridian?: boolean;\n    showSeconds?: boolean;\n}\n\nexport class DynamicTimePickerModel extends DynamicDateControlModel {\n\n    @serializable() meridian: boolean;\n    @serializable() showSeconds: boolean;\n\n    @serializable() readonly type: string = DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER;\n\n    constructor(config: DynamicTimePickerModelConfig, layout?: DynamicFormControlLayout) {\n\n        super(config, layout);\n\n        this.meridian = typeof config.meridian === \"boolean\" ? config.meridian : false;\n        this.showSeconds = typeof config.showSeconds === \"boolean\" ? config.showSeconds : false;\n    }\n}","import { InjectionToken, Injectable, Inject, Optional } from \"@angular/core\";\nimport {\n    AbstractControl,\n    AsyncValidatorFn,\n    ValidatorFn,\n    Validators,\n    NG_VALIDATORS,\n    NG_ASYNC_VALIDATORS\n} from \"@angular/forms\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport {\n    DynamicValidatorDescriptor,\n    DynamicValidatorsConfig\n} from \"../model/misc/dynamic-form-control-validation.model\";\n\nexport type Validator = ValidatorFn | AsyncValidatorFn;\n\nexport type ValidatorFactory = (args: any) => Validator;\n\nexport type ValidatorsToken = Validator[];\n\nexport type ValidatorsMap = Map<string, Validator | ValidatorFactory>;\n\nexport const DYNAMIC_VALIDATORS = new InjectionToken<ValidatorsMap>(\"DYNAMIC_VALIDATORS\");\n\n@Injectable()\nexport class DynamicFormValidationService {\n\n    constructor(@Optional() @Inject(NG_VALIDATORS) private NG_VALIDATORS: ValidatorFn[],\n                @Optional() @Inject(NG_ASYNC_VALIDATORS) private NG_ASYNC_VALIDATORS: AsyncValidatorFn[],\n                @Optional() @Inject(DYNAMIC_VALIDATORS) private DYNAMIC_VALIDATORS: Map<string, Validator | ValidatorFactory>) {}\n\n\n    private getValidatorFn(validatorName: string, validatorArgs: any = null,\n                           validatorsToken: ValidatorsToken = this.NG_VALIDATORS): Validator | never {\n\n        let validatorFn: ValidatorFactory | Validator | undefined;\n\n        if (Validators.hasOwnProperty(validatorName)) { // Built-in Angular Validators\n\n            validatorFn = (Validators as any)[validatorName];\n\n        } else { // Custom Validators\n\n            if (this.DYNAMIC_VALIDATORS && this.DYNAMIC_VALIDATORS.has(validatorName)) {\n                validatorFn = this.DYNAMIC_VALIDATORS.get(validatorName);\n\n            } else if (validatorsToken) {\n                validatorFn = validatorsToken.find(validatorFn => validatorFn.name === validatorName);\n            }\n        }\n\n        if (validatorFn === undefined) { // throw when no validator could be resolved\n            throw new Error(`validator \"${validatorName}\" is not provided via NG_VALIDATORS, NG_ASYNC_VALIDATORS or DYNAMIC_FORM_VALIDATORS`);\n        }\n\n        if (validatorArgs !== null) {\n            return (validatorFn as ValidatorFactory)(validatorArgs);\n        }\n\n        return validatorFn as Validator;\n    }\n\n\n    private getValidatorFns(validatorsConfig: DynamicValidatorsConfig,\n                            validatorsToken: ValidatorsToken = this.NG_VALIDATORS): Validator[] {\n\n        let validatorFns: Validator[] = [];\n\n        if (validatorsConfig && typeof validatorsConfig === \"object\") {\n\n            validatorFns = Object.keys(validatorsConfig).map(validatorConfigKey => {\n\n                let validatorConfigValue = validatorsConfig[validatorConfigKey];\n\n                if (this.isValidatorDescriptor(validatorConfigValue)) {\n\n                    let descriptor = validatorConfigValue as DynamicValidatorDescriptor;\n\n                    return this.getValidatorFn(descriptor.name, descriptor.args, validatorsToken);\n                }\n\n                return this.getValidatorFn(validatorConfigKey, validatorConfigValue, validatorsToken);\n            });\n        }\n\n        return validatorFns;\n    }\n\n\n    private parseErrorMessageConfig(template: string, model: DynamicFormControlModel, error: any = null): string {\n\n        return template.replace(/{{\\s*(.+?)\\s*}}/mg, (_match: string, expression: string) => {\n\n            let propertySource: any = model,\n                propertyName: string = expression;\n\n            if (expression.indexOf(\"validator.\") >= 0 && error) {\n\n                propertySource = error;\n                propertyName = expression.replace(\"validator.\", \"\");\n            }\n\n            return propertySource[propertyName] ? propertySource[propertyName] : null;\n        });\n    }\n\n\n    getValidator(validatorName: string, validatorArgs: any = null): ValidatorFn {\n        return this.getValidatorFn(validatorName, validatorArgs) as ValidatorFn;\n    }\n\n\n    getAsyncValidator(validatorName: string, validatorArgs: any = null): AsyncValidatorFn {\n        return this.getValidatorFn(validatorName, validatorArgs, this.NG_ASYNC_VALIDATORS) as AsyncValidatorFn;\n    }\n\n\n    getValidators(validatorsConfig: DynamicValidatorsConfig): ValidatorFn[] {\n        return this.getValidatorFns(validatorsConfig) as ValidatorFn[];\n    }\n\n\n    getAsyncValidators(asyncValidatorsConfig: DynamicValidatorsConfig): AsyncValidatorFn[] {\n        return this.getValidatorFns(asyncValidatorsConfig, this.NG_ASYNC_VALIDATORS) as AsyncValidatorFn[];\n    }\n\n\n    updateValidators(validatorsConfig: DynamicValidatorsConfig | null, control: AbstractControl,\n                     model: DynamicFormControlModel): void {\n\n        model.validators = validatorsConfig;\n\n        if (validatorsConfig === null) {\n\n            control.clearValidators();\n\n        } else {\n            control.setValidators(this.getValidators(validatorsConfig));\n        }\n    }\n\n\n    updateAsyncValidators(asyncValidatorsConfig: DynamicValidatorsConfig | null, control: AbstractControl,\n                          model: DynamicFormControlModel): void {\n\n        model.asyncValidators = asyncValidatorsConfig;\n\n        if (asyncValidatorsConfig === null) {\n\n            control.clearAsyncValidators();\n\n        } else {\n            control.setAsyncValidators(this.getAsyncValidators(asyncValidatorsConfig));\n        }\n    }\n\n\n    createErrorMessages(control: AbstractControl, model: DynamicFormControlModel): string[] {\n\n        let messages: string[] = [];\n\n        if (typeof model.errorMessages === \"object\" && model.errorMessages !== null) {\n\n            let messagesConfig = model.errorMessages as DynamicValidatorsConfig;\n\n            Object.keys(control.errors || {}).forEach(validationErrorKey => {\n\n                let messageKey = validationErrorKey;\n\n                if (validationErrorKey === \"minlength\" || validationErrorKey === \"maxlength\") {\n                    messageKey = messageKey.replace(\"length\", \"Length\");\n                }\n\n                if (messagesConfig.hasOwnProperty(messageKey)) {\n\n                    let validationError = control.getError(validationErrorKey),\n                        messageTemplate = messagesConfig[messageKey] as string;\n\n                    messages.push(this.parseErrorMessageConfig(messageTemplate, model, validationError));\n                }\n            });\n        }\n\n        return messages;\n    }\n\n\n    isFormHook(value: any): boolean {\n        return typeof value === \"string\" && [\"blur\", \"change\", \"submit\"].indexOf(value) !== -1;\n    }\n\n\n    isValidatorDescriptor(value: any): boolean {\n\n        if (value !== null && typeof value === \"object\") {\n            return value.hasOwnProperty(\"name\") && value.hasOwnProperty(\"args\");\n        }\n\n        return false;\n    }\n}","import { Injectable } from \"@angular/core\";\nimport { AbstractControl, FormArray, FormControl, FormGroup } from \"@angular/forms\";\nimport { AbstractControlOptions, FormHooks } from \"@angular/forms/src/model\";\nimport { DynamicFormControlModel } from \"../model/dynamic-form-control.model\";\nimport { DynamicFormValueControlModel, DynamicFormControlValue } from \"../model/dynamic-form-value-control.model\";\nimport {\n    DynamicFormArrayModel,\n    DYNAMIC_FORM_CONTROL_TYPE_ARRAY,\n    DynamicFormArrayGroupModel\n} from \"../model/form-array/dynamic-form-array.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_GROUP, DynamicFormGroupModel } from \"../model/form-group/dynamic-form-group.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP,\n    DynamicCheckboxGroupModel\n} from \"../model/checkbox/dynamic-checkbox-group.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX, DynamicCheckboxModel } from \"../model/checkbox/dynamic-checkbox.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER,\n    DynamicColorPickerModel\n} from \"../model/colorpicker/dynamic-colorpicker.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER,\n    DynamicDatePickerModel\n} from \"../model/datepicker/dynamic-datepicker.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_EDITOR, DynamicEditorModel } from \"../model/editor/dynamic-editor.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD,\n    DynamicFileUploadModel\n} from \"../model/file-upload/dynamic-file-upload.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_INPUT, DynamicInputModel } from \"../model/input/dynamic-input.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP,\n    DynamicRadioGroupModel\n} from \"../model/radio/dynamic-radio-group.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_RATING, DynamicRatingModel } from \"../model/rating/dynamic-rating.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SELECT, DynamicSelectModel } from \"../model/select/dynamic-select.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SLIDER, DynamicSliderModel } from \"../model/slider/dynamic-slider.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_SWITCH, DynamicSwitchModel } from \"../model/switch/dynamic-switch.model\";\nimport { DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA, DynamicTextAreaModel } from \"../model/textarea/dynamic-textarea.model\";\nimport {\n    DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER,\n    DynamicTimePickerModel\n} from \"../model/timepicker/dynamic-timepicker.model\";\nimport { DynamicPathable } from \"../model/misc/dynamic-form-control-path.model\";\nimport { DynamicValidatorsConfig } from \"../model/misc/dynamic-form-control-validation.model\";\nimport { DynamicFormValidationService } from \"./dynamic-form-validation.service\";\nimport { JSONUtils } from \"../utils/json.utils\";\n\nexport type DynamicFormModel = DynamicFormControlModel[] | DynamicFormGroupModel;\n\n@Injectable()\nexport class DynamicFormService {\n\n    constructor(private validationService: DynamicFormValidationService) {}\n\n\n    private createAbstractControlOptions(validatorsConfig: DynamicValidatorsConfig | null = null,\n                                         asyncValidatorsConfig: DynamicValidatorsConfig | null = null,\n                                         updateOn: FormHooks | null = null): AbstractControlOptions {\n\n        return {\n\n            asyncValidators: asyncValidatorsConfig !== null ? this.validationService.getAsyncValidators(asyncValidatorsConfig) : null,\n\n            validators: validatorsConfig !== null ? this.validationService.getValidators(validatorsConfig) : null,\n\n            updateOn: updateOn !== null && this.validationService.isFormHook(updateOn) ? updateOn : \"change\"\n        };\n    }\n\n\n    createFormArray(formArrayModel: DynamicFormArrayModel): FormArray {\n\n        let controls: AbstractControl[] = [],\n            options = this.createAbstractControlOptions(formArrayModel.validators, formArrayModel.asyncValidators,\n                formArrayModel.updateOn);\n\n        for (let index = 0; index < formArrayModel.size; index++) {\n\n            let groupModel = formArrayModel.get(index),\n                groupOptions = this.createAbstractControlOptions(formArrayModel.groupValidators,\n                    formArrayModel.groupAsyncValidators, formArrayModel.updateOn);\n\n            controls.push(this.createFormGroup(groupModel.group, groupOptions, groupModel));\n        }\n\n        return new FormArray(controls, options);\n    }\n\n\n    createFormGroup(formModel: DynamicFormControlModel[], options: AbstractControlOptions | null = null,\n                    parent: DynamicPathable | null = null): FormGroup {\n\n        let controls: { [controlId: string]: AbstractControl; } = {};\n\n        formModel.forEach(model => {\n\n            model.parent = parent;\n\n            switch (model.type) {\n\n                case DYNAMIC_FORM_CONTROL_TYPE_ARRAY:\n\n                    controls[model.id] = this.createFormArray(model as DynamicFormArrayModel);\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_GROUP:\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP:\n\n                    let groupModel = model as DynamicFormGroupModel,\n                        groupOptions = this.createAbstractControlOptions(groupModel.validators,\n                            groupModel.asyncValidators, groupModel.updateOn);\n\n                    controls[model.id] = this.createFormGroup(groupModel.group, groupOptions, groupModel);\n                    break;\n\n                default:\n\n                    let controlModel = model as DynamicFormValueControlModel<DynamicFormControlValue>,\n                        controlState = {value: controlModel.value, disabled: controlModel.disabled},\n                        controlOptions = this.createAbstractControlOptions(controlModel.validators,\n                            controlModel.asyncValidators, controlModel.updateOn);\n\n                    controls[model.id] = new FormControl(controlState, controlOptions);\n            }\n        });\n\n        return new FormGroup(controls, options);\n    }\n\n\n    getPathSegment(model: DynamicPathable): string {\n\n        return model instanceof DynamicFormArrayGroupModel ? model.index.toString() : (model as DynamicFormControlModel).id;\n    }\n\n\n    getPath(model: DynamicPathable): string[] {\n\n        let path = [this.getPathSegment(model)],\n            parent = model.parent;\n\n        while (parent) {\n\n            path.unshift(this.getPathSegment(parent));\n            parent = parent.parent;\n        }\n\n        return path;\n    }\n\n\n    addFormGroupControl(formGroup: FormGroup, formModel: DynamicFormModel, ...models: DynamicFormControlModel[]): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            this.insertFormGroupControl(formModel.size(), formGroup, formModel, ...models);\n\n        } else {\n\n            let _formModel = formModel as DynamicFormControlModel[];\n            this.insertFormGroupControl(_formModel.length, formGroup, _formModel, ...models);\n        }\n    }\n\n\n    moveFormGroupControl(index: number, step: number, formModel: DynamicFormModel): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            formModel.move(index, step);\n\n        } else {\n\n            let _formModel = formModel as DynamicFormControlModel[];\n            _formModel.splice(index + step, 0, ..._formModel.splice(index, 1));\n        }\n    }\n\n\n    insertFormGroupControl(index: number, formGroup: FormGroup, formModel: DynamicFormModel,\n                           ...models: DynamicFormControlModel[]): void {\n\n        let parent = formModel instanceof DynamicFormGroupModel ? formModel : null,\n            controls = this.createFormGroup(models, null, parent).controls;\n\n        Object.keys(controls).forEach((controlName, idx) => {\n\n            let controlModel = models[idx];\n\n            if (formModel instanceof DynamicFormGroupModel) {\n                formModel.insert(index, controlModel);\n\n            } else {\n                (formModel as DynamicFormControlModel[]).splice(index, 0, controlModel);\n            }\n\n            formGroup.addControl(controlName, controls[controlName]);\n        });\n    }\n\n\n    removeFormGroupControl(index: number, formGroup: FormGroup, formModel: DynamicFormModel): void {\n\n        if (formModel instanceof DynamicFormGroupModel) {\n\n            formGroup.removeControl(formModel.get(index).id);\n            formModel.remove(index);\n\n        } else {\n\n            formGroup.removeControl(formModel[index].id);\n            (formModel as DynamicFormControlModel[]).splice(index, 1);\n        }\n    }\n\n\n    addFormArrayGroup(formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let groupModel = formArrayModel.addGroup();\n\n        formArray.push(this.createFormGroup(groupModel.group, null, groupModel));\n    }\n\n\n    insertFormArrayGroup(index: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let groupModel = formArrayModel.insertGroup(index);\n\n        formArray.insert(index, this.createFormGroup(groupModel.group, null, groupModel));\n    }\n\n\n    moveFormArrayGroup(index: number, step: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        let newIndex = index + step,\n            moveUp = step >= 0;\n\n        if ((index >= 0 && index < formArrayModel.size) && (newIndex >= 0 && newIndex < formArrayModel.size)) {\n\n            let movingGroups: AbstractControl[] = [];\n\n            for (let i = moveUp ? index : newIndex; i <= (moveUp ? newIndex : index); i++) {\n                movingGroups.push(formArray.at(i));\n            }\n\n            movingGroups.forEach((formControl, idx) => {\n\n                let position;\n\n                if (moveUp) {\n                    position = idx === 0 ? newIndex : index + idx - 1;\n\n                } else {\n                    position = idx === movingGroups.length - 1 ? newIndex : newIndex + idx + 1;\n                }\n\n                formArray.setControl(position, formControl);\n            });\n\n            formArrayModel.moveGroup(index, step);\n\n        } else {\n            throw new Error(`form array group cannot be moved due to index or new index being out of bounds`);\n        }\n    }\n\n\n    removeFormArrayGroup(index: number, formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        formArray.removeAt(index);\n        formArrayModel.removeGroup(index);\n    }\n\n\n    clearFormArray(formArray: FormArray, formArrayModel: DynamicFormArrayModel): void {\n\n        while (formArray.length > 0) {\n            this.removeFormArrayGroup(0, formArray, formArrayModel);\n        }\n    }\n\n\n    findById(id: string, formModel: DynamicFormControlModel[]): DynamicFormControlModel | null {\n\n        let result = null,\n            findByIdFn = (id: string, groupModel: DynamicFormControlModel[]): void => {\n\n                for (let controlModel of groupModel) {\n\n                    if (controlModel.id === id) {\n                        result = controlModel;\n                        break;\n                    }\n\n                    if (controlModel instanceof DynamicFormGroupModel) {\n                        findByIdFn(id, (controlModel as DynamicFormGroupModel).group);\n                    }\n                }\n            };\n\n        findByIdFn(id, formModel);\n\n        return result;\n    }\n\n\n    fromJSON(json: string | object[]): DynamicFormControlModel[] | never {\n\n        let formModelJSON = typeof json === \"string\" ? JSON.parse(json, JSONUtils.parseReviver) : json,\n            formModel: DynamicFormControlModel[] = [];\n\n        formModelJSON.forEach((model: any) => {\n\n            let layout = model.layout || model.cls || null;\n\n            switch (model.type) {\n\n                case DYNAMIC_FORM_CONTROL_TYPE_ARRAY:\n                    let formArrayModel = model as DynamicFormArrayModel;\n\n                    if (Array.isArray(formArrayModel.groups)) {\n                        formArrayModel.groups.forEach((groupModel: DynamicFormArrayGroupModel) => {\n                            groupModel.group = this.fromJSON(groupModel.group) as DynamicFormControlModel[];\n                        });\n                    }\n\n                    formArrayModel.groupFactory = () => {\n                        return this.fromJSON(formArrayModel.groupPrototype || formArrayModel.origin);\n                    };\n\n                    formModel.push(new DynamicFormArrayModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX:\n                    formModel.push(new DynamicCheckboxModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP:\n                    model.group = this.fromJSON(model.group) as DynamicCheckboxModel[];\n                    formModel.push(new DynamicCheckboxGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER:\n                    formModel.push(new DynamicColorPickerModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER:\n                    formModel.push(new DynamicDatePickerModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_EDITOR:\n                    formModel.push(new DynamicEditorModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD:\n                    model.value = null;\n                    formModel.push(new DynamicFileUploadModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_GROUP:\n                    model.group = this.fromJSON(model.group);\n                    formModel.push(new DynamicFormGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_INPUT:\n                    let inputModel = model as DynamicInputModel;\n\n                    if (inputModel.mask !== null) {\n                        inputModel.mask = JSONUtils.maskFromString(inputModel.mask as string);\n                    }\n\n                    formModel.push(new DynamicInputModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP:\n                    formModel.push(new DynamicRadioGroupModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_RATING:\n                    formModel.push(new DynamicRatingModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SELECT:\n                    formModel.push(new DynamicSelectModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SLIDER:\n                    formModel.push(new DynamicSliderModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_SWITCH:\n                    formModel.push(new DynamicSwitchModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA:\n                    formModel.push(new DynamicTextAreaModel(model, layout));\n                    break;\n\n                case DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER:\n                    formModel.push(new DynamicTimePickerModel(model, layout));\n                    break;\n\n                default:\n                    throw new Error(`unknown form control model type defined on JSON object with id \"${model.id}\"`);\n            }\n        });\n\n        return formModel;\n    }\n}","import { Injectable } from \"@angular/core\";\nimport {\n    DynamicFormControlLayoutConfig,\n    DynamicFormControlLayout\n} from \"../model/misc/dynamic-form-control-layout.model\";\n\nexport type DynamicFormLayout = { [id: string]: DynamicFormControlLayout };\n\n@Injectable()\nexport class DynamicFormLayoutService {\n\n    findById(id: string, formLayout: DynamicFormLayout | null): DynamicFormControlLayout | null {\n\n        if (formLayout !== null && typeof formLayout === \"object\") {\n\n            for (let key of Object.keys(formLayout)) {\n\n                if (key === id) {\n                    return formLayout[key];\n                }\n            }\n        }\n\n        return null;\n    }\n\n    getClass(layout: DynamicFormControlLayout | null, context: string, place: string): string {\n\n        if (layout !== null && layout.hasOwnProperty(context)) {\n\n            let config = layout[context] as DynamicFormControlLayoutConfig;\n\n            if (config.hasOwnProperty(place)) {\n                return config[place] as string;\n            }\n        }\n\n        return \"\";\n    }\n}","import { CommonModule } from \"@angular/common\";\nimport { NgModule, ModuleWithProviders } from \"@angular/core\";\nimport { ReactiveFormsModule } from \"@angular/forms\";\nimport { DynamicFormService } from \"./service/dynamic-form.service\";\nimport { DynamicFormLayoutService } from \"./service/dynamic-form-layout.service\";\nimport { DynamicFormValidationService } from \"./service/dynamic-form-validation.service\";\nimport { DynamicIdDirective } from \"./directive/dynamic-id.directive\";\nimport { DynamicTemplateDirective } from \"./directive/dynamic-template.directive\";\n\n@NgModule({\n    imports: [\n        CommonModule,\n        ReactiveFormsModule\n    ],\n    declarations: [\n        DynamicIdDirective,\n        DynamicTemplateDirective\n    ],\n    exports: [\n        DynamicIdDirective,\n        DynamicTemplateDirective\n    ]\n})\nexport class DynamicFormsCoreModule {\n\n    static forRoot(): ModuleWithProviders {\n\n        return {\n\n            ngModule: DynamicFormsCoreModule,\n\n            providers: [\n                DynamicFormService,\n                DynamicFormLayoutService,\n                DynamicFormValidationService\n            ]\n        };\n    }\n}"],"names":["METADATA_KEY_SERIALIZABLE","name","target","key","Reflect","defineMetadata","serializables","metadata","getMetadata","push","prototype","getSerializables","reduce","prev","prop","config","layout","this","asyncValidators","errorMessages","hidden","id","label","relation","Array","isArray","updateOn","validators","disabled","disabledUpdates","Subject","subscribe","_this","Object","DynamicFormControlModel","_disabled","value","serialize","serializable","_super","additional","hint","required","tabIndex","valueUpdates","__extends","DynamicFormValueControlModel","_value","context","group","index","$implicit","DynamicFormArrayGroupModel","DYNAMIC_FORM_CONTROL_TYPE_ARRAY","groupFactory","Error","groupAsyncValidators","groupPrototype","groupValidators","initialCount","groups","forEach","arrayGroup","addGroup","DynamicFormArrayModel","length","insertGroup","splice","updateGroupIndex","step","_a","AUTOCOMPLETE_ON","AUTOFILL_TOKENS_ADDRESS","AUTOFILL_TOKENS_CONTACT","AUTOFILL_FIELDS","AUTOFILL_FIELDS_CONTACT","AutoFillUtils","token","indexOf","startsWith","tokens","toExpression","total","currentValue","tokensAddress","tokensContact","fields","fieldsContact","RegExp","test","autoComplete","autoFocus","maxLength","minLength","placeholder","prefix","readOnly","spellCheck","suffix","JSONUtils","mask","toString","map","maskToString","endsWith","slice","maskFromString","_key","Date","DYNAMIC_FORM_CONTROL_TYPE_INPUT","DYNAMIC_FORM_CONTROL_INPUT_TYPE_TEXT","accept","inputType","list","max","undefined","min","multiple","pattern","listId","DynamicInputModel","json","toJSON","DynamicInputControlModel","DYNAMIC_TEMPLATE_DIRECTIVE_ALIGN_END","templateRef","Directive","selector","TemplateRef","Input","RelationUtils","relGroups","rel","find","action","model","controlGroup","controls","relGroup","when","control","get","some","controlElement","_formGroup","formGroup","toBeDisabled","connective","status","DynamicFormControlComponent","changeDetectorRef","layoutService","validationService","changes","groupChange","modelChange","unsubscribe","subscriptions","valueChanges","onControlValueChanges","onModelDisabledUpdates","onModelValueUpdates","setControlRelations","setTemplates","detectChanges","createErrorMessages","invalid","valid","hasErrorMessaging","touched","hasFocus","isInvalid","inputTemplateList","contentTemplateList","place","controlLayout","getClass","defaultValue","hasOwnProperty","$event","type","templateList","template","modelType","modelId","as","templates","DynamicFormControlComponentTemplatePosition","array","align","start","end","relActivation","findActivationRelation","rel_1","updateModelDisabled","getRelatedFormControls","statusChanges","next","isFormControlToBeDisabled","subscription","setValue","disable","enable","Event","inputElement","srcElement","files","change","emit","createDynamicFormControlEvent","isDynamicFormControlEvent","blur","focus","customEvent","DynamicFormComponent","formService","_index","findById","formLayout","elementRef","renderer","DynamicIdDirective","dynamicId","setAttribute","nativeElement","ElementRef","Renderer2","labelPosition","DynamicCheckControlModel","checked","format","__window","__self","self","__global","isObject","tryCatcher","errorObject","tryCatchTarget","fn","errors","err","call","hasErrors","closed","_parent","isFunction","e","UnsubscriptionError","_subscriptions","len","sub","teardown","subscriptionIndex","_parents","error","rxSubscriber","b","arguments","destination","destinationOrNext","create","Subscriber","observerOrNext","complete","_context","_complete","_parentSubscriber","__tryOrUnsub","isStopped","wrappedComplete","$$observable","Symbol","lift","operator","observable","source","sink","nextOrObserver","syncErrorThrowable","syncErrorThrown","syncErrorValue","root","reject","subscriber","operations","fns","input","toPromise","ScalarObservable","scheduler","done","state","EmptyObservable","isScheduler","ArrayObservable","_i","count","MapPolyfill","i","_keys","_values","size","cb","thisArg","MapOperator","result","DynamicFormOption","text","options","DynamicOptionControlModel","options$","of","_options","optionConfig","updateOptions$","Observable","pipe","optionsConfig","insert","option","indices","DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX","indeterminate","DYNAMIC_FORM_CONTROL_TYPE_GROUP","legend","DynamicFormGroupModel","controlModel","DYNAMIC_FORM_CONTROL_TYPE_CHECKBOX_GROUP","DynamicCheckboxGroupModel","DYNAMIC_FORM_CONTROL_TYPE_COLORPICKER","inline","DYNAMIC_FORM_CONTROL_TYPE_DATEPICKER","focusedDate","toggleIcon","toggleLabel","DynamicDateControlModel","DYNAMIC_FORM_CONTROL_TYPE_EDITOR","DYNAMIC_FORM_CONTROL_TYPE_FILE_UPLOAD","autoUpload","maxSize","minSize","removeUrl","showFileList","url","DynamicFileControlModel","DYNAMIC_FORM_CONTROL_TYPE_RADIO_GROUP","DynamicRadioGroupModel","DYNAMIC_FORM_CONTROL_TYPE_RATING","DYNAMIC_FORM_CONTROL_TYPE_SELECT","filterable","DynamicSelectModel","DYNAMIC_FORM_CONTROL_TYPE_SLIDER","vertical","DYNAMIC_FORM_CONTROL_TYPE_SWITCH","offLabel","onLabel","DYNAMIC_FORM_CONTROL_TYPE_TEXTAREA","DYNAMIC_FORM_TEXTAREA_WRAP_SOFT","cols","rows","wrap","DYNAMIC_FORM_CONTROL_TYPE_TIMEPICKER","meridian","showSeconds","DYNAMIC_VALIDATORS","InjectionToken","NG_VALIDATORS","NG_ASYNC_VALIDATORS","DynamicFormValidationService","validatorName","validatorArgs","validatorsToken","validatorFn","Validators","has","validatorsConfig","validatorFns","keys","validatorConfigKey","validatorConfigValue","isValidatorDescriptor","descriptor","getValidatorFn","args","replace","_match","expression","propertySource","propertyName","getValidatorFns","asyncValidatorsConfig","clearValidators","setValidators","getValidators","clearAsyncValidators","setAsyncValidators","getAsyncValidators","messages","messagesConfig_1","validationErrorKey","messageKey","validationError","getError","messageTemplate","parseErrorMessageConfig","Injectable","Optional","Inject","DynamicFormService","isFormHook","formArrayModel","createAbstractControlOptions","groupModel","groupOptions","createFormGroup","FormArray","formModel","parent","createFormArray","controlState","controlOptions","FormControl","FormGroup","path","getPathSegment","unshift","models","insertFormGroupControl","_formModel","move","controlName","idx","addControl","removeControl","remove","formArray","newIndex","moveUp","movingGroups_1","at","formControl","position","setControl","moveGroup","removeAt","removeGroup","removeFormArrayGroup","findByIdFn","groupModel_1","JSON","parse","parseReviver","cls","formArrayModel_1","fromJSON","origin","DynamicCheckboxModel","DynamicColorPickerModel","DynamicDatePickerModel","DynamicEditorModel","DynamicFileUploadModel","inputModel","DynamicRatingModel","DynamicSliderModel","DynamicSwitchModel","DynamicTextAreaModel","DynamicTimePickerModel","DynamicFormLayoutService","DynamicFormsCoreModule","ngModule","providers","NgModule","imports","CommonModule","ReactiveFormsModule","declarations","DynamicTemplateDirective","exports"],"mappings":"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"}